task*1：需求模块化分析
输入： docs/init_docs/ 目录下的所有业务需求文档。
执行逻辑：
域识别： 扫描文档，根据业务关联性将功能划分为独立的业务域（Domain）。
职责定义： 明确每个域的业务边界，解决“谁负责什么”的问题。
核心建模： 提取各域中的核心名词（Entity），建立初步的逻辑关联。
完成准则： 产出 01*需求模块化方案.md，且模块划分无职责重合。

task*2：需求原子化拆分
输入： 01*需求模块化方案.md。
执行逻辑：
细化： 将模块拆解为具体的 Feature（功能点）。
原子化： 将 Feature 进一步拆解为“原子任务”（如：后端接口 A、前端页面 B、公共组件 C）。
水平拆分（按模块）： 依据 01 号文档将功能归入对应的业务域。
垂直拆分（按层级）： 强制将功能拆分为 [后端接口]、[前端页面/组件]、[公共逻辑/中间件]。
多维评估： 针对每个任务，AI 需自动评估其 [预估工时]、[涉及端点]、[复杂度权重]。
关联映射： 标记该任务对其他模块的潜在影响。

task*3：系统架构设计
输入： 项目技术栈.md + 编码规范.md。
执行逻辑：
后端模式： 定义 NestJS 的层级调用规范、异常处理管道、全局 DTO 校验规则 等。
前端模式： 定义 Taro 的页面路由策略、Pinia 状态管理结构等。
通用组件规范： 提取原子任务中可能重复使用的公共逻辑/组件。
完成准则： 产出 03*系统架构设计方案.md。

task*4：接口与数据规约
输入： 01*需求模块化方案.md + 03*系统架构设计方案.md。
执行逻辑：
DB 建模： 设计数据库表结构（ER 图），包含字段类型、索引、外键约束。
API 契约： 定义所有原子任务涉及的 API 路径、Method、请求/响应 DTO。
完成准则： 产出 04*接口与数据规约.md。
