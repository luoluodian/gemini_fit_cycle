# 任务清单 - 优化版 (Task Checklist - Optimized)

> **版本**: v2.0  
> **最后更新**: 2026-01-27  
> **适用项目**: Gemini Fit Cycle  
> **优化重点**: 增强可执行性、明确验收标准、建立质量保证机制

---

## 📌 文档说明

本任务清单旨在指导 AI 助手系统化地分析项目需求并生成高质量的技术文档。每个任务都包含：

- ✅ **明确的输入输出**
- ✅ **详细的执行步骤**
- ✅ **可验证的完成标准**
- ✅ **质量检查清单**
- ✅ **依赖关系说明**

---

## 🔄 任务执行流程图

```
┌─────────────────┐
│   Task 1        │  需求模块化分析
│   (基础层)       │  ↓ 输出: 01_需求模块化方案.md
└─────────────────┘
         ↓
┌─────────────────┐
│   Task 2        │  需求原子化拆分
│   (细化层)       │  ↓ 输出: 02_需求原子化拆分.md
└─────────────────┘
         ↓
┌─────────────────┐
│   Task 3        │  系统架构设计
│   (架构层)       │  ↓ 输出: 03_系统架构设计方案.md
└─────────────────┘
         ↓
┌─────────────────┐
│   Task 4        │  接口与数据规约
│   (契约层)       │  ↓ 输出: 04_接口与数据规约.md
└─────────────────┘
```

---

## 📋 Task 1: 需求模块化分析

### 🎯 任务目标

将分散的业务需求按照领域驱动设计 (DDD) 的思想，划分为高内聚、低耦合的业务域。

### 📥 输入文件

- `docs/init_docs/页面功能详细说明文档.md`
- `docs/init_docs/项目技术栈.md`
- `docs/init_docs/编码规范.md`

### 🔧 执行逻辑

#### 步骤 1: 域识别 (Domain Identification)

1. **扫描所有页面和功能点**
   - 提取所有名词（如：用户、食物、计划、记录）
   - 提取所有动词（如：登录、添加、查询、分享）
2. **按业务关联性聚类**
   - 将相关的名词和动词组合成候选域
   - 识别核心域（Core Domain）和支撑域（Supporting Domain）
3. **验证域的独立性**
   - 确保每个域有明确的业务边界
   - 检查域之间是否存在职责重叠

#### 步骤 2: 职责定义 (Responsibility Definition)

为每个域明确回答以下问题：

- **What**: 这个域负责什么业务？
- **Why**: 为什么需要这个域？
- **Who**: 谁会使用这个域的功能？
- **When**: 在什么场景下使用？

#### 步骤 3: 核心建模 (Core Modeling)

1. **识别核心实体 (Entity)**
   - 提取每个域中的核心名词
   - 定义实体的关键属性
2. **建立实体关系**
   - 一对一 (1:1)
   - 一对多 (1:N)
   - 多对多 (M:N)

3. **识别值对象 (Value Object)**
   - 无需唯一标识的对象（如：营养素、地址）

#### 步骤 4: 依赖分析 (Dependency Analysis)

- 绘制域之间的依赖关系图
- 标注强依赖和弱依赖
- 识别循环依赖并提出解决方案

### 📤 输出文件

**文件名**: `docs/pj_docs/01_需求模块化方案.md`

**必须包含的章节**:

1. **核心业务域划分表**
   - 域名称、核心职责、核心实体
2. **各业务域详细说明**
   - 业务边界、核心实体、关键功能
3. **域关联与依赖关系图**
   - 使用 Mermaid 或文字描述
4. **边界上下文映射 (Context Mapping)**
   - 说明域之间如何协作

### ✅ 完成标准 (Definition of Done)

#### 必须满足 (Must Have)

- [ ] 识别出 4-6 个核心业务域
- [ ] 每个域的职责描述清晰且无重叠
- [ ] 每个域至少包含 2-5 个核心实体
- [ ] 域之间的依赖关系明确标注
- [ ] 文档结构完整，包含所有必需章节

#### 质量检查 (Quality Check)

- [ ] **单一职责原则**: 每个域只负责一个业务领域
- [ ] **高内聚**: 域内实体和功能紧密相关
- [ ] **低耦合**: 域之间依赖最小化
- [ ] **可理解性**: 非技术人员能理解域的划分逻辑
- [ ] **可扩展性**: 新功能能清晰地归入某个域

#### 验证方法

```bash
# 人工检查
1. 阅读文档，确认每个域的职责是否清晰
2. 尝试将新功能归类，验证域划分的合理性
3. 检查是否存在"上帝域"（职责过多的域）
```

---

## 📋 Task 2: 需求原子化拆分

### 🎯 任务目标

将模块化的业务域进一步拆解为可独立开发、测试和交付的原子任务。

### 📥 输入文件

- `docs/pj_docs/01_需求模块化方案.md` (Task 1 的输出)
- `docs/init_docs/页面功能详细说明文档.md`

### 🔧 执行逻辑

#### 步骤 1: 功能点提取 (Feature Extraction)

1. **从域到功能**
   - 将每个域的"关键功能"展开为具体的功能点
   - 每个功能点应该是用户可感知的完整功能
2. **功能点优先级评估**
   - P0: MVP 必需功能
   - P1: 重要但非紧急
   - P2: 优化和增强功能

#### 步骤 2: 垂直拆分 (Vertical Slicing)

将每个功能点按技术层级拆分：

- **[后端 API]**: 接口实现、业务逻辑、数据持久化
- **[前端页面]**: 页面级组件
- **[前端组件]**: 可复用的 UI 组件
- **[前端服务]**: API 调用封装、状态管理
- **[公共逻辑]**: 工具函数、中间件、拦截器

#### 步骤 3: 水平拆分 (Horizontal Slicing)

将任务归入对应的业务域：

- 确保每个任务明确属于某个域
- 跨域任务应标注为 `[跨域]` 并说明涉及的域

#### 步骤 4: 多维评估 (Multi-dimensional Assessment)

为每个原子任务评估：

1. **预估工时 (Estimated Effort)**
   - 单位：人时 (1 = 2-4小时)
   - 考虑：编码、自测、文档
2. **技术复杂度 (Complexity)**
   - 低：CRUD 操作、简单 UI
   - 中：包含业务逻辑、状态管理
   - 高：复杂算法、性能优化、跨域协调
3. **涉及端点 (Affected Endpoints)**
   - B: Backend
   - F: Frontend
   - S: Shared (前后端共享)
4. **依赖任务 (Dependencies)**
   - 列出必须先完成的任务 ID
5. **风险评估 (Risk)**
   - 技术风险、需求不明确、外部依赖

#### 步骤 5: 任务关联映射 (Task Relationship Mapping)

- 标记任务之间的依赖关系
- 识别可并行开发的任务组
- 标注潜在的阻塞点

### 📤 输出文件

**文件名**: `docs/pj_docs/02_需求原子化拆分.md`

**必须包含的章节**:

1. **任务评估标准说明**
2. **按业务域分组的任务表**
   - 任务 ID、描述、垂直拆分、工时、复杂度、依赖
3. **任务依赖关系图** (可选但推荐)
4. **开发排期建议** (基于依赖关系)

### ✅ 完成标准 (Definition of Done)

#### 必须满足 (Must Have)

- [ ] 每个域至少拆分出 5-10 个原子任务
- [ ] 每个任务都有唯一的 ID（如 U-1, DL-2）
- [ ] 每个任务都包含完整的评估维度
- [ ] 任务粒度适中（2-8 小时可完成）
- [ ] 依赖关系清晰标注

#### 质量检查 (Quality Check)

- [ ] **原子性**: 任务不可再拆分且能独立交付
- [ ] **可测试性**: 每个任务有明确的验收标准
- [ ] **无遗漏**: 覆盖所有需求文档中的功能点
- [ ] **无冗余**: 没有重复的任务
- [ ] **可排期**: 基于依赖关系可生成开发计划

#### 验证方法

```bash
# 自动检查
1. 统计任务总数，确保覆盖所有功能
2. 检查任务 ID 是否唯一
3. 验证依赖任务 ID 是否存在

# 人工检查
1. 随机抽取 5 个任务，验证是否可独立开发
2. 检查是否存在"巨型任务"（工时 > 16h）
3. 验证 P0 任务是否形成完整的 MVP
```

---

## 📋 Task 3: 系统架构设计

### 🎯 任务目标

基于技术栈和编码规范，定义项目的技术架构、分层模式和开发规范。

### 📥 输入文件

- `docs/init_docs/项目技术栈.md`
- `docs/init_docs/编码规范.md`
- `docs/pj_docs/02_需求原子化拆分.md` (了解技术需求)

### 🔧 执行逻辑

#### 步骤 1: 后端架构设计 (Backend Architecture)

1. **分层结构定义**
   - Controller 层：职责、规范、示例
   - Service 层：职责、规范、示例
   - Repository 层：职责、规范、示例
   - Entity 层：职责、规范、示例
2. **请求处理流程**
   - 绘制完整的请求生命周期图
   - 说明每个环节的职责
3. **核心机制设计**
   - 全局异常处理
   - 统一响应格式
   - DTO 自动校验
   - 认证与授权
   - 日志记录
   - 事务管理

#### 步骤 2: 前端架构设计 (Frontend Architecture)

1. **目录结构规范**
   - pages/: 页面组件
   - components/: 可复用组件
   - services/: API 服务
   - stores/: 状态管理
   - utils/: 工具函数
   - constants/: 常量定义
2. **状态管理策略**
   - Pinia Store 设计原则
   - State、Getters、Actions 的职责
   - 跨组件通信方案
3. **路由与鉴权**
   - 路由配置规范
   - 路由守卫实现
   - 页面权限控制
4. **样式方案**
   - Tailwind CSS 使用规范
   - Sass 补充场景
   - 响应式设计策略

#### 步骤 3: 通用组件/逻辑设计 (Shared Components)

1. **识别可复用组件**
   - 从原子任务中提取重复的 UI 模式
   - 定义组件的 Props、Events、Slots
2. **通用服务设计**
   - HTTP 请求封装
   - 本地存储封装
   - 错误处理服务
   - Toast/Loading 服务

#### 步骤 4: 数据流设计 (Data Flow)

1. **前后端数据流**
   ```
   用户操作 → 组件 → Action → API Service → 后端 Controller
   → Service → Repository → Database
   → Service → Controller → API Service → Action → 组件 → 视图更新
   ```
2. **状态同步策略**
   - 乐观更新 vs 悲观更新
   - 缓存策略
   - 离线支持

### 📤 输出文件

**文件名**: `docs/pj_docs/03_系统架构设计方案.md`

**必须包含的章节**:

1. **总体架构说明** (Monorepo 结构)
2. **后端架构**
   - 分层结构与职责
   - 请求处理生命周期
   - 核心机制设计
3. **前端架构**
   - 目录结构规范
   - 状态管理策略
   - 路由与鉴权
   - 样式方案
4. **通用组件/逻辑设计概要**
5. **数据流设计**
6. **开发规范速查表**

### ✅ 完成标准 (Definition of Done)

#### 必须满足 (Must Have)

- [ ] 后端分层清晰，每层职责明确
- [ ] 前端目录结构符合最佳实践
- [ ] 包含至少 3 个核心机制的详细设计
- [ ] 提供代码示例（每个层级至少 1 个）
- [ ] 数据流图清晰可读

#### 质量检查 (Quality Check)

- [ ] **一致性**: 与技术栈文档和编码规范一致
- [ ] **可落地性**: 开发人员能直接按照文档编码
- [ ] **完整性**: 覆盖所有技术层面
- [ ] **可维护性**: 架构支持未来扩展
- [ ] **最佳实践**: 符合 NestJS 和 Vue 3 的官方推荐

#### 验证方法

```bash
# 人工检查
1. 对照技术栈文档，确认所有技术都有对应的架构设计
2. 检查是否有"架构空白"（某个技术层面没有设计）
3. 验证代码示例是否可运行
4. 评估架构的可扩展性（假设新增一个模块）
```

---

## 📋 Task 4: 接口与数据规约

### 🎯 任务目标

定义详细的数据库表结构和 API 接口契约，作为前后端并行开发的"唯一真理来源"。

### 📥 输入文件

- `docs/pj_docs/01_需求模块化方案.md` (实体模型)
- `docs/pj_docs/02_需求原子化拆分.md` (API 需求)
- `docs/pj_docs/03_系统架构设计方案.md` (技术约束)

### 🔧 执行逻辑

#### 步骤 1: 数据库建模 (Database Modeling)

1. **实体设计**
   - 为每个核心实体定义 TypeORM Entity
   - 包含字段名、类型、约束、注释
2. **关系设计**
   - 定义实体之间的关系（@OneToMany, @ManyToOne, @ManyToMany）
   - 明确外键约束和级联操作
3. **索引设计**
   - 为高频查询字段添加索引
   - 考虑复合索引
4. **ER 图绘制**
   - 使用 Mermaid 或其他工具绘制实体关系图

#### 步骤 2: API 契约定义 (API Contract)

为每个原子任务中的 `[后端 API]` 定义：

1. **基础信息**
   - HTTP Method (GET/POST/PUT/PATCH/DELETE)
   - 路径 (Path)
   - 认证要求
2. **请求规约**
   - Path Parameters
   - Query Parameters
   - Request Body (DTO 定义)
   - Request Headers
3. **响应规约**
   - Success Response (200/201/204)
   - Error Responses (400/401/403/404/500)
   - Response Body 结构
4. **业务规则**
   - 数据验证规则
   - 业务约束
   - 边界条件

#### 步骤 3: DTO 定义 (Data Transfer Object)

1. **Request DTO**
   - 定义所有请求体的 TypeScript 接口
   - 标注验证规则（class-validator 装饰器）
2. **Response DTO**
   - 定义所有响应体的 TypeScript 接口
   - 说明字段含义和数据类型

#### 步骤 4: 数据字典 (Data Dictionary)

1. **枚举类型定义**
   - 餐次类型 (MealType)
   - 计划状态 (PlanStatus)
   - 用户角色等
2. **常量定义**
   - 营养素单位
   - 默认值
   - 限制值（如最大文件大小）

### 📤 输出文件

**文件名**: `docs/pj_docs/04_接口与数据规约.md`

**必须包含的章节**:

1. **数据库实体模型**
   - 每个实体的 TypeORM 定义
   - ER 图
2. **API 接口契约**
   - 按业务域分组
   - 每个接口的完整规约
3. **DTO 定义汇总**
4. **数据字典**
5. **API 调用示例** (可选但推荐)

### ✅ 完成标准 (Definition of Done)

#### 必须满足 (Must Have)

- [ ] 所有核心实体都有 TypeORM 定义
- [ ] 所有原子任务中的 API 都有契约定义
- [ ] 每个 API 都包含请求和响应示例
- [ ] DTO 定义完整且类型安全
- [ ] 包含 ER 图

#### 质量检查 (Quality Check)

- [ ] **完整性**: 覆盖所有数据和接口需求
- [ ] **一致性**: 实体关系与业务逻辑一致
- [ ] **规范性**: 符合 RESTful 设计原则
- [ ] **可实现性**: 后端开发可直接按照契约编码
- [ ] **可测试性**: 前端可基于契约进行 Mock 测试

#### 验证方法

```bash
# 自动检查
1. 验证所有 API 路径是否符合 RESTful 规范
2. 检查 DTO 字段类型是否一致
3. 验证外键关系是否双向定义

# 人工检查
1. 对照原子任务表，确认所有 API 都已定义
2. 检查是否存在"孤儿实体"（没有被任何 API 使用）
3. 验证 API 设计是否支持所有业务场景
```

---

## 📋 Task 4.5: 初始化原子任务交付看板

### 🎯 任务目标

创建动态交付看板，追踪每个原子任务的交付进度（分析→编码→测试→评审→交付）。

### 📥 输入文件

- `docs/pj_docs/02_需求原子化拆分.md`

### 🔧 执行逻辑

#### 步骤 1: 扫描原子任务

- 读取 02 文档中的所有原子任务
- 提取任务 ID、名称、优先级、预估工时

#### 步骤 2: 创建看板矩阵

- 每行 = 一个原子任务
- 每列 = 交付阶段（T5-T9）
- 初始状态：所有任务标记为 📅 (待开始)

#### 步骤 3: 定义状态图标

- 📅 待开始
- 🏃 进行中
- ✅ 已完成
- ⚠️ 有风险
- ❌ 已阻塞

### 📤 输出文件

**文件名**: `docs/pj_docs/04.5_原子任务交付看板.md`

**看板格式**:
| 任务ID | 任务名称 | 优先级 | T5-分析 | T6-编码 | T7-测试 | T8-评审 | T9-交付 | 预估工时 | 状态 |
|--------|----------|--------|---------|---------|---------|---------|---------|----------|------|
| U-1 | 用户登录接口 | P0 | 📅 | 📅 | 📅 | 📅 | 📅 | 4h | 待开始 |

### ✅ 完成标准

- [ ] 所有原子任务都已录入看板
- [ ] 看板格式规范统一
- [ ] 包含状态图标说明
- [ ] 添加看板更新规则说明

---

## 🔄 第二阶段：原子任务交付循环

> **重要**: 以下 Task 5-9 针对看板中的**每个原子任务**循环执行

---

## 📋 Task 5: 原子需求分析与设计 (T5-分析)

### 🎯 任务目标

在编码前进行详细的技术分析和设计，识别风险点。

### 📥 输入

- 当前原子任务的描述（来自 02 文档）
- 相关的 API 契约（来自 04 文档）
- 系统架构设计（来自 03 文档）

### 🔧 执行步骤

#### 5.1 模块关联性审计

- [ ] 检查是否涉及公共数据表
- [ ] 检查是否涉及公共组件
- [ ] 检查是否涉及跨模块 Service
- [ ] 列出所有关联模块

#### 5.2 影响评估

- [ ] 识别需要修改的现有文件
- [ ] 评估对现有功能的影响
- [ ] 列出必须参考的文件路径
- [ ] 标记潜在的破坏性变更

#### 5.3 技术落地计划

- [ ] 定义新增的类名/文件名
- [ ] 定义新增的方法名/函数名
- [ ] 设计 UI 交互流程（如适用）
- [ ] 确定数据流向

### 📤 输出

在任务工作目录创建 `T5_分析文档.md`，包含：

- 模块关联分析
- 影响评估结果
- 技术实现方案
- 风险点清单

### ✅ 完成标准

- [ ] 分析文档完整
- [ ] 所有风险点已识别
- [ ] 技术方案可行
- [ ] **更新看板**: 将该任务的 T5 列更新为 ✅

---

## 📋 Task 6: 原子功能编码实现 (T6-编码)

### 🎯 任务目标

按照 T5 的设计方案，规范地实现功能代码。

### 📥 输入

- `T5_分析文档.md`
- `docs/init_docs/编码规范.md`

### 🔧 执行步骤

#### 6.1 环境预检

- [ ] 检查 npm packages 是否需要新增
- [ ] 检查环境变量 (.env) 是否需要配置
- [ ] 确认数据库迁移是否需要执行

#### 6.2 规范编码

**后端编码**:

- [ ] 创建/修改 Entity
- [ ] 创建/修改 DTO
- [ ] 实现 Service 业务逻辑
- [ ] 实现 Controller 接口
- [ ] 添加必要的注释

**前端编码**:

- [ ] 创建/修改页面组件
- [ ] 创建/修改可复用组件
- [ ] 实现 API Service 调用
- [ ] 实现 Pinia Store (如需要)
- [ ] 实现样式（Tailwind + Sass）

#### 6.3 变更记录

创建 `T6_变更清单.md`，记录：

- 新建的文件列表
- 修改的文件列表
- 新增的依赖包
- 环境变量变更

### ✅ 完成标准

- [ ] 代码符合编码规范
- [ ] 代码可编译/构建通过
- [ ] 变更清单完整
- [ ] **更新看板**: 将该任务的 T6 列更新为 ✅

---

## 📋 Task 7: 功能测试与联调验证 (T7-测试)

### 🎯 任务目标

验证功能的正确性、鲁棒性和兼容性。

### 📥 输入

- 已实现的代码
- `T5_分析文档.md` 中的风险点清单

### 🔧 执行步骤

#### 7.1 链路跑通测试

- [ ] 启动后端服务
- [ ] 启动前端应用
- [ ] 测试正常业务流程
- [ ] 验证数据正确性

#### 7.2 鲁棒性验证

- [ ] 测试空值 (null/undefined)
- [ ] 测试非法格式输入
- [ ] 测试边界值
- [ ] 测试并发场景（如适用）
- [ ] Taro 跨端兼容性测试

#### 7.3 回归测试

- [ ] 针对 T5 识别的风险点进行测试
- [ ] 验证关联功能未受影响
- [ ] 检查性能是否符合预期

### 📤 输出

创建 `T7_测试报告.md`，包含：

- 测试用例列表
- 测试结果（通过/失败）
- 发现的 Bug 列表
- 性能数据

### ✅ 完成标准

- [ ] 所有测试用例通过
- [ ] 无阻塞性 Bug
- [ ] 测试报告完整
- [ ] **更新看板**: 将该任务的 T7 列更新为 ✅

---

## 📋 Task 8: AI 代码审计与评审 (T8-评审)

### 🎯 任务目标

通过 AI 自动审计代码质量、性能和安全性。

### 📥 输入

- `T6_变更清单.md` 中的文件列表
- `docs/init_docs/编码规范.md`

### 🔧 执行步骤

#### 8.1 规范审计

- [ ] 命名规范检查（变量、函数、类）
- [ ] 代码格式检查（缩进、空格）
- [ ] 注释完整性检查
- [ ] 文件结构规范检查

#### 8.2 质量审计

**后端**:

- [ ] SQL 查询性能分析
- [ ] 索引使用检查
- [ ] N+1 查询检测
- [ ] 事务使用检查
- [ ] 安全漏洞扫描（SQL 注入、XSS）

**前端**:

- [ ] 组件渲染性能分析
- [ ] 状态管理合理性检查
- [ ] 内存泄漏风险检测
- [ ] 无用代码检测

### 📤 输出

创建 `T8_审计报告.md`，包含：

- 规范问题清单
- 性能问题清单
- 安全问题清单
- 优化建议

### ✅ 完成标准

- [ ] 无严重规范问题
- [ ] 无严重性能问题
- [ ] 无安全漏洞
- [ ] **更新看板**: 将该任务的 T8 列更新为 ✅

---

## 📋 Task 9: 功能交付与归档同步 (T9-交付)

### 🎯 任务目标

正式交付功能，同步看板状态，归档文档。

### 📥 输入

- 所有 T5-T8 的输出文档
- 已测试通过的代码

### 🔧 执行步骤

#### 9.1 Git 物理提交

# 提交格式

git add .
git commit -m "feat(模块名): 任务描述 (#任务ID)"
git push origin feature/任务ID

## 🚀 使用建议

### 对于 AI 助手

1. **严格按照步骤执行**：不要跳过任何步骤
2. **输出完整文档**：确保包含所有必需章节
3. **自我检查**：完成后对照检查清单验证
4. **保持一致性**：使用统一的术语和格式

### 对于人类审查者

1. **重点检查完成标准**：确保所有 DoD 都满足
2. **验证可执行性**：开发人员能否直接使用文档
3. **检查遗漏**：是否有功能没有被覆盖
4. **评估质量**：文档是否清晰、准确、完整

---

## 📝 版本历史

| 版本 | 日期       | 变更说明                               |
| ---- | ---------- | -------------------------------------- |
| v1.0 | 2026-01-20 | 初始版本                               |
| v2.0 | 2026-01-27 | 优化版：增加验收标准、质量检查、Task 5 |

---

**文档结束**
