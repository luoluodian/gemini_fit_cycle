# Gemini CLI 提示词模板库

> **版本**: v2.2 (联调增强版)  
> **适用于**: 任务清单 v4.2  
> **工具**: Gemini CLI  
> **更新日期**: 2026-01-28  
> **更新内容**: T7 测试阶段增加前后端联调测试，新增联调检查清单

---

## ⚠️ 重要：AI 执行规则（所有任务必须遵守）

### 🛡️ 通用防护规则

在执行任何任务前，必须遵守以下规则：

#### 1. 反幻觉规则
```
❌ 禁止假设任何文件存在
❌ 禁止假设任何函数存在
❌ 禁止假设任何配置存在
❌ 禁止引用未验证的路径

✅ 必须先验证，再引用
✅ 使用 ls/find/grep 命令验证
✅ 如果不确定，明确说明"需要验证"
✅ 所有验证结果都要输出
```

#### 2. 反重复规则
```
❌ 禁止在不检查的情况下创建新代码
❌ 禁止创建已存在的功能

✅ 必须先扫描现有代码库
✅ 必须检查是否已存在类似功能
✅ 优先复用现有代码
✅ 如果必须新建，说明为什么不能复用
```

#### 3. 完整性规则
```
❌ 禁止只修改部分相关代码
❌ 禁止遗漏导入语句
❌ 禁止遗漏类型定义
❌ 禁止遗漏模块注册

✅ 必须识别所有相关文件
✅ 必须更新所有相关配置
✅ 必须执行完整性检查清单
✅ 必须列出所有变更
```

#### 4. 透明度规则
```
✅ 明确说明每一步在做什么
✅ 明确说明为什么这样做
✅ 明确说明还有什么需要做
✅ 如果不确定，明确说明不确定的地方
✅ 输出所有验证和检查结果
```

#### 5. 分步执行规则
```
✅ 复杂任务必须分阶段执行
✅ 每个阶段完成后输出结果
✅ 等待确认后再继续下一阶段
✅ 不要一次性完成所有步骤
```

---

## 📌 使用说明

本文档包含所有任务执行阶段的标准化提示词模板。直接复制提示词，替换 `{task_id}` 等占位符后，在 Gemini CLI 中执行。

### 占位符说明
- `{task_id}`: 任务ID，如 U-3, F-1, L-6
- `{task_name}`: 任务名称，如"构建登录页面 UI"
- `{priority}`: 优先级，如 P0, P1, P2
- `{date}`: 日期，如 2026-01-27

### ⚠️ 重要提示
- **所有提示词都已包含防护规则**
- **建议先生成代码库索引**（见下方）
- **建议使用分步执行模式**

---

## 🔍 阶段 0: 项目分析与规划

### 0.1 分析当前任务清单

```
分析当前任务清单的执行情况：

1. 读取 docs/pj_docs/04.5_原子任务交付看板.md
2. 统计各优先级任务的完成情况：
   - P0 任务: 总数、已完成、进度
   - P1 任务: 总数、已完成、进度
   - P2 任务: 总数、已完成、进度
3. 识别当前可以开始的任务（无依赖或依赖已完成）
4. 按优先级和依赖关系推荐下一步应该执行的任务
5. 标注可以并行执行的任务组

请以清晰的格式输出分析结果。
```

### 0.2 查看特定任务详情

```
查看任务 {task_id} 的详细信息：

1. 从 docs/pj_docs/02_需求原子化拆分.md 中提取任务定义
2. 显示以下信息：
   - 任务ID和名称
   - 优先级
   - 垂直拆分类型
   - 预估工时
   - 复杂度
   - 依赖任务
3. 检查依赖任务是否已完成
4. 判断该任务是否可以立即开始

请以结构化的格式输出。
```

### 0.3 生成本周开发计划

```
基于当前进度，生成本周开发计划：

1. 读取 docs/pj_docs/04.5_原子任务交付看板.md
2. 分析当前进度和剩余任务
3. 按照以下原则制定计划：
   - 优先完成 P0 任务
   - 优先完成数据库设计任务（通常是其他任务的依赖）
   - 识别可并行执行的任务
   - 考虑任务复杂度和预估工时
4. 生成本周计划，包括：
   - 每日任务安排
   - 预期完成的任务数量
   - 里程碑目标

请输出详细的周计划。
```

---

## 📋 阶段 1: 任务初始化

### 1.1 初始化新任务（标准版）

```
初始化任务 {task_id}：

1. 创建任务工作目录：
   - 路径: docs/pj_docs/tasks/{task_id}/

2. 从模板目录复制文件到任务目录：
   - docs/templates/T5_分析文档_模板.md → T5_分析文档.md
   - docs/templates/T6_变更清单_模板.md → T6_变更清单.md
   - docs/templates/T7_测试报告_模板.md → T7_测试报告.md
   - docs/templates/T8_审计报告_模板.md → T8_审计报告.md
   - docs/templates/T8.5_审查意见_模板.md → T8.5_审查意见.md

3. 在任务目录创建 README.md，内容包括：
   - 任务基本信息
   - 文档清单
   - 执行流程
   - 参考资料链接

4. 确认完成后，告诉我任务已准备好，并显示任务目录结构。
```

### 1.2 初始化新任务（简化版 - P2任务）

```
初始化 P2 任务 {task_id}（简化流程）：

1. 创建任务工作目录：docs/pj_docs/tasks/{task_id}/

2. 仅复制必需的模板文件：
   - T5_分析文档_模板.md（简化版）
   - T6_变更清单_模板.md

3. 创建简化版 README.md

4. 确认完成。
```

---

## 🔬 阶段 2: T5 需求分析

### 2.1 执行 T5 分析（完整版 - P0/P1任务）

```
执行任务 {task_id} 的 T5 分析阶段：

**任务信息**：
- 任务ID: {task_id}
- 任务名称: {task_name}
- 优先级: {priority}

**执行步骤**：

1. 读取相关文档：
   - docs/pj_docs/02_需求原子化拆分.md（任务定义）
   - docs/pj_docs/04_接口与数据规约.md（API 契约）
   - docs/pj_docs/03_系统架构设计方案.md（架构规范）
   - docs/init_docs/编码规范.md（编码规范）

2. 如果是前端任务，分析对应的 HTML 原型：
   - 查找 html/ 目录下对应的文件
   - 分析 DOM 结构、样式特征、交互逻辑

3. 填写 T5_分析文档.md，包括：
   - 5.1 模块关联性审计
   - 5.2 影响评估
   - 5.3 技术落地计划
   - 5.4 风险点清单
   - 5.5 预期交付物

4. 保存到：docs/pj_docs/tasks/{task_id}/T5_分析文档.md

5. 更新看板：
   - 在 docs/pj_docs/04.5_原子任务交付看板.md 中
   - 将任务 {task_id} 的 T5 列更新为 ✅

6. 完成后，输出分析摘要和识别的风险点。
```

### 2.2 执行 T5 分析（简化版 - P2任务）

```
执行 P2 任务 {task_id} 的 T5 快速分析：

1. 读取任务定义和相关 API 契约
2. 生成简化版 T5 分析文档，仅包括：
   - 技术方案概述
   - 涉及的文件列表
   - 主要风险点
3. 保存到任务目录
4. 更新看板 T5 列为 ✅

请在 30 分钟内完成。
```

---

## 💻 阶段 3: T6 功能编码（防护增强版）

> **重要**: T6 编码阶段采用 **8 阶段执行流程**，强制执行防护机制

### 3.1 执行 T6 编码（后端任务）- 防护增强版

```
【AI 执行规则 - 必须遵守】

1. 反幻觉规则：
   ❌ 禁止假设任何文件存在
   ❌ 禁止假设任何函数存在
   ❌ 禁止假设任何配置存在
   ✅ 必须先验证，再引用
   ✅ 使用 ls/find/grep 命令验证
   ✅ 所有验证结果都要输出

2. 反重复规则：
   ❌ 禁止在不检查的情况下创建新代码
   ✅ 必须先扫描现有代码库
   ✅ 优先复用现有代码
   ✅ 如果必须新建，说明为什么不能复用

3. 完整性规则：
   ❌ 禁止只修改部分相关代码
   ✅ 必须识别所有相关文件
   ✅ 必须更新所有相关配置
   ✅ 必须执行完整性检查清单

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

执行任务 {task_id} 的 T6 编码阶段（后端）：

【阶段 1: 上下文扫描 - 必须执行，不可跳过】

1.1 扫描现有后端模块：
命令: ls -la fit_cycle_app/src/modules/
输出: [列出所有现有模块]

1.2 扫描现有公共工具：
命令: ls -la fit_cycle_app/src/common/utils/
输出: [列出所有工具函数]

1.3 扫描现有 DTO：
命令: ls -la fit_cycle_app/src/dtos/
输出: [列出所有 DTO]

1.4 搜索相关功能（根据任务名称）：
命令: find fit_cycle_app/src -name "*{关键词}*"
输出: [列出相关文件]

1.5 输出扫描报告：
```
【扫描报告】
现有模块: [列表]
现有工具: [列表]
现有 DTO: [列表]
相关文件: [列表]
可复用代码: [列表]
需要新建: [列表]
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 2: 读取相关文档 - 必须执行】

2.1 读取任务分析文档：
文件: docs/pj_docs/tasks/{task_id}/T5_分析文档.md
内容: [输出关键内容]

2.2 读取编码规范：
文件: docs/init_docs/编码规范.md
内容: [输出关键规范]

2.3 读取架构设计：
文件: docs/pj_docs/03_系统架构设计方案.md
内容: [输出相关架构规范]

2.4 读取接口规约：
文件: docs/pj_docs/04_接口与数据规约.md
内容: [输出相关接口定义]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 3: 验证依赖 - 必须执行】

3.1 验证 npm 包是否已安装：
命令: grep "{包名}" fit_cycle_app/package.json
结果: [存在/不存在]

3.2 验证相关 Entity 是否存在：
命令: ls fit_cycle_app/src/database/entity/{entity}.entity.ts
结果: [存在/不存在]

3.3 验证相关 Service 是否存在：
命令: ls fit_cycle_app/src/modules/{module}/{service}.service.ts
结果: [存在/不存在]

3.4 验证相关 DTO 是否存在：
命令: ls fit_cycle_app/src/dtos/{dto}.dto.ts
结果: [存在/不存在]

3.5 输出验证报告：
```
【验证报告】
已安装的包: [列表]
已存在的 Entity: [列表]
已存在的 Service: [列表]
已存在的 DTO: [列表]
需要创建的文件: [列表]
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 4: 制定创建计划 - 必须输出并等待确认】

4.1 列出需要创建的文件：
```
需要创建的文件：
1. [文件路径] - [功能说明]
2. [文件路径] - [功能说明]
...
```

4.2 列出需要修改的文件：
```
需要修改的文件：
1. [文件路径] - [修改内容]
2. [文件路径] - [修改内容]
...
```

4.3 列出可复用的现有代码：
```
可复用的现有代码：
1. [文件路径] - [功能] - [如何复用]
2. [文件路径] - [功能] - [如何复用]
...
```

4.4 列出依赖关系：
```
依赖关系：
- [文件A] 依赖 [文件B]
- [文件C] 依赖 [文件D]
...
```

⚠️ 请确认以上计划后，我再继续执行。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 5: 逐文件实现 - 等待确认后执行】

对于每个需要创建的文件：

5.1 说明该文件的功能
5.2 列出该文件的依赖
5.3 验证所有依赖都存在（使用 ls/grep 命令）
5.4 实现该文件的代码
5.5 添加必要的注释
5.6 输出实现结果

⚠️ 每个文件实现完成后，等待确认再继续下一个文件。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 6: 完整性检查 - 必须执行】

6.1 导入语句检查：
- [ ] 所有导入的模块都已安装？（验证 package.json）
- [ ] 所有导入的文件路径都正确？（验证文件存在）
- [ ] 所有导入的类/函数都存在？（验证代码）

6.2 类型定义检查：
- [ ] 所有使用的类型都已定义？
- [ ] 所有 DTO 都已创建？
- [ ] 所有接口都已声明？

6.3 模块注册检查：
- [ ] 新的 Service 是否已注册到 Module？
- [ ] 新的 Controller 是否已注册到 Module？
- [ ] 新的 Module 是否已导入到 AppModule？

6.4 依赖注入检查：
- [ ] 所有依赖的 Service 是否已注入？
- [ ] 循环依赖是否已避免？

6.5 配置文件检查：
- [ ] 环境变量是否已添加？
- [ ] 配置项是否已更新？

6.6 数据库检查：
- [ ] 数据库迁移是否已创建？
- [ ] Entity 关系是否正确？

输出检查结果：
```
【完整性检查结果】
✅ 通过项: [列表]
❌ 未通过项: [列表]
⚠️ 需要注意项: [列表]
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 7: 生成变更清单】

7.1 汇总所有变更
7.2 填写 T6_变更清单.md
7.3 保存到 docs/pj_docs/tasks/{task_id}/T6_变更清单.md
7.4 更新看板 T6 列为 ✅

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 8: 最终输出】

输出变更摘要：
```
【变更摘要】
新建文件: [数量] 个
修改文件: [数量] 个
复用代码: [数量] 处
新增依赖: [数量] 个
总代码行数: [数量] 行
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ 重要提示：
1. 请严格按照阶段执行，不要跳过任何步骤
2. 每个阶段完成后输出结果
3. 阶段 4 完成后等待我的确认
4. 阶段 5 每个文件完成后等待我的确认
5. 如果不确定，明确说明不确定的地方
```

### 3.2 执行 T6 编码（前端任务）- 防护增强版

```
【AI 执行规则 - 必须遵守】
[同上]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

执行任务 {task_id} 的 T6 编码阶段（前端）：

【阶段 1: 上下文扫描 - 必须执行】

1.1 扫描现有前端页面：
命令: ls -la fit_cycle_web/src/pages/
输出: [列出所有现有页面]

1.2 扫描现有组件：
命令: ls -la fit_cycle_web/src/components/
输出: [列出所有现有组件]

1.3 扫描现有 Store：
命令: ls -la fit_cycle_web/src/stores/
输出: [列出所有 Store]

1.4 扫描现有 Service：
命令: ls -la fit_cycle_web/src/services/
输出: [列出所有 Service]

1.5 搜索相关功能：
命令: find fit_cycle_web/src -name "*{关键词}*"
输出: [列出相关文件]

1.6 输出扫描报告：
```
【扫描报告】
现有页面: [列表]
现有组件: [列表]
现有 Store: [列表]
现有 Service: [列表]
可复用代码: [列表]
需要新建: [列表]
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 2: 分析 HTML 原型 - 必须执行】

2.1 读取 HTML 原型文件：
文件: html/{对应文件}.html
内容: [输出完整内容或关键部分]

2.2 分析 DOM 结构：
```
【DOM 结构分析】
主要容器: [列表]
关键元素: [列表]
嵌套层级: [说明]
```

2.3 分析样式特征：
```
【样式分析】
主要颜色: [列表]
字体样式: [列表]
布局方式: [说明]
响应式断点: [列表]
```

2.4 分析交互逻辑：
```
【交互分析】
用户操作: [列表]
事件处理: [列表]
数据流向: [说明]
```

2.5 识别可复用组件：
```
【可复用组件】
现有组件: [列表]
需要新建: [列表]
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 3: 验证依赖 - 必须执行】

3.1 验证 Store 是否存在：
命令: ls fit_cycle_web/src/stores/{store}.ts
结果: [存在/不存在]

3.2 验证 Service 是否存在：
命令: ls fit_cycle_web/src/services/modules/{service}.ts
结果: [存在/不存在]

3.3 验证路由配置：
命令: grep "{路由路径}" fit_cycle_web/src/router/index.ts
结果: [存在/不存在]

3.4 验证公共组件：
命令: ls fit_cycle_web/src/components/common/{component}/
结果: [存在/不存在]

3.5 输出验证报告：
```
【验证报告】
已存在的 Store: [列表]
已存在的 Service: [列表]
已存在的组件: [列表]
需要创建的文件: [列表]
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 4: 制定创建计划 - 必须输出并等待确认】

4.1 列出需要创建的文件：
```
需要创建的文件：
1. [文件路径] - [功能说明]
2. [文件路径] - [功能说明]
...
```

4.2 列出需要修改的文件：
```
需要修改的文件：
1. [文件路径] - [修改内容]
2. [文件路径] - [修改内容]
...
```

4.3 列出 UI 迁移计划：
```
UI 迁移计划：
1. HTML 结构 → Vue Template
2. 原生 CSS → Tailwind CSS + Sass
3. 静态数据 → Store/API 数据
4. JS 交互 → Vue 事件处理
```

4.4 列出可复用的现有组件：
```
可复用组件：
1. [组件路径] - [功能] - [如何复用]
2. [组件路径] - [功能] - [如何复用]
...
```

⚠️ 请确认以上计划后，我再继续执行。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 5: 逐文件实现 - 等待确认后执行】

对于每个需要创建的文件：

5.1 说明该文件的功能
5.2 列出该文件的依赖
5.3 验证所有依赖都存在
5.4 实现该文件的代码
5.5 实现 UI 迁移（如适用）
5.6 添加必要的注释
5.7 输出实现结果

⚠️ 每个文件实现完成后，等待确认再继续下一个文件。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 6: 完整性检查 - 必须执行】

6.1 导入语句检查：
- [ ] 所有导入的组件都已创建？
- [ ] 所有导入的 Store 都存在？
- [ ] 所有导入的 Service 都存在？
- [ ] 所有导入的工具函数都存在？

6.2 类型定义检查：
- [ ] 所有 Props 类型都已定义？
- [ ] 所有 Emits 类型都已定义？
- [ ] 所有接口都已声明？

6.3 路由配置检查：
- [ ] 路由是否已添加到 router/index.ts？
- [ ] 路由守卫是否已应用？
- [ ] 路由路径是否正确？

6.4 Store 检查：
- [ ] State 是否已定义？
- [ ] Actions 是否已实现？
- [ ] Getters 是否已实现？

6.5 UI 还原度检查：
- [ ] 布局结构是否与原型一致？
- [ ] 颜色样式是否与原型一致？
- [ ] 字体样式是否与原型一致？
- [ ] 间距尺寸是否与原型一致？

6.6 响应式检查：
- [ ] 移动端显示是否正常？
- [ ] 平板显示是否正常？
- [ ] 桌面端显示是否正常？

输出检查结果：
```
【完整性检查结果】
✅ 通过项: [列表]
❌ 未通过项: [列表]
⚠️ 需要注意项: [列表]
UI 还原度: [X]%
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 7: 生成变更清单】

7.1 汇总所有变更
7.2 填写 T6_变更清单.md（包含 UI 迁移记录）
7.3 保存到 docs/pj_docs/tasks/{task_id}/T6_变更清单.md
7.4 更新看板 T6 列为 ✅

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 8: 最终输出】

输出变更摘要：
```
【变更摘要】
新建文件: [数量] 个
修改文件: [数量] 个
复用组件: [数量] 个
UI 还原度: [X]%
总代码行数: [数量] 行
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ 重要提示：
1. 请严格按照阶段执行，不要跳过任何步骤
2. 每个阶段完成后输出结果
3. 阶段 4 完成后等待我的确认
4. 阶段 5 每个文件完成后等待我的确认
5. 如果不确定，明确说明不确定的地方
```

---

## 🧪 阶段 4: T7 功能测试（联调增强版）

### 4.1 执行 T7 测试（完整版 - 后端任务）

```
执行任务 {task_id} 的 T7 测试阶段（后端）：

**测试准备**：
1. 读取 T5_分析文档.md 中的风险点清单
2. 读取 T6_变更清单.md 了解变更内容
3. 读取 docs/pj_docs/04_接口与数据规约.md 确认接口契约

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.1 单元测试】

1. 正常流程测试：
   - 设计并执行正常业务流程测试用例
   - 记录测试结果

2. 边界条件测试：
   - 测试空值（null, undefined, ""）
   - 测试最大值/最小值
   - 测试特殊字符
   - 测试超长字符串

3. 异常场景测试：
   - 测试无效参数
   - 测试权限不足
   - 测试资源不存在
   - 测试网络超时

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.2 接口联调测试】⭐ 必做

4. 使用 Postman 或 curl 测试接口：
   
   4.1 验证接口路径：
   - [ ] 路径与接口规约一致
   - [ ] 路径参数正确
   - [ ] 查询参数正确
   
   4.2 验证请求格式：
   - [ ] Content-Type 正确
   - [ ] 请求体结构符合 DTO 定义
   - [ ] 必填字段都存在
   
   4.3 验证响应格式：
   - [ ] 响应状态码正确（200/201/400/401/500）
   - [ ] 响应体结构符合契约
   - [ ] 字段类型正确
   - [ ] 错误响应格式统一
   
   4.4 验证 CORS 配置：
   - [ ] 允许前端域名访问
   - [ ] 允许必要的 HTTP 方法
   - [ ] 允许必要的请求头
   
   4.5 提供测试示例：
   ```bash
   # 成功场景示例
   curl -X POST http://localhost:3000/api/auth/login \
     -H "Content-Type: application/json" \
     -d '{"code": "wx_code_123"}'
   
   # 响应示例
   {
     "code": 0,
     "data": {
       "access_token": "eyJhbGc...",
       "refresh_token": "eyJhbGc...",
       "user": { ... }
     },
     "message": "success"
   }
   
   # 失败场景示例
   curl -X POST http://localhost:3000/api/auth/login \
     -H "Content-Type: application/json" \
     -d '{"code": ""}'
   
   # 响应示例
   {
     "code": 40001,
     "message": "微信授权码不能为空"
   }
   ```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.3 性能测试】

5. 测试性能指标：
   - 接口响应时间（目标 < 1s）
   - 数据库查询次数（避免 N+1）
   - 内存占用

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.4 回归测试】

6. 验证 T5 中识别的风险点
7. 测试关联功能是否受影响

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.5 生成报告】

8. 填写 T7_测试报告.md，包括：
   - 测试环境信息
   - 单元测试用例和结果
   - 接口联调测试结果（包含 curl 示例）⭐
   - 发现的问题（按严重程度分级）
   - 性能数据
   - 测试结论

9. 保存并更新看板 T7 列为 ✅

10. 如果发现阻塞性问题，标记看板为 🔴 并返回 T6 修复

11. 完成后，输出测试摘要和问题清单。
```

### 4.2 执行 T7 测试（完整版 - 前端任务）🔗 联调增强

```
执行任务 {task_id} 的 T7 测试阶段（前端）：

**测试准备**：
1. 读取 T5_分析文档.md 中的风险点清单
2. 读取 T6_变更清单.md 了解变更内容
3. 读取 docs/pj_docs/04_接口与数据规约.md 确认接口契约
4. 读取 docs/templates/前后端联调检查清单.md ⭐

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.1 单元测试】

1. 正常流程测试：
   - 设计并执行正常业务流程测试用例
   - 记录测试结果

2. 边界条件测试：
   - 测试空值、边界值
   - 测试特殊字符
   - 测试超长输入

3. 异常场景测试：
   - 测试无效输入
   - 测试网络错误
   - 测试加载状态

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.2 接口联调测试】⭐ 必做

⚠️ 前提条件：对应的后端接口已完成 T9 交付

4. 接口契约验证：

   4.1 验证接口路径：
   命令: 打开浏览器 Network 面板，执行前端操作
   检查: 
   - [ ] 请求路径与后端一致
   - [ ] 路径参数正确
   - [ ] 查询参数正确
   
   示例输出：
   ```
   【Network 面板检查】
   Request URL: http://localhost:3000/api/auth/login
   Request Method: POST
   Status Code: 200 OK
   ```
   
   4.2 验证请求格式：
   检查:
   - [ ] Content-Type: application/json
   - [ ] 请求体结构符合 DTO
   - [ ] 必填字段都已传递
   
   示例输出：
   ```
   【Request Headers】
   Content-Type: application/json
   Authorization: Bearer eyJhbGc...
   
   【Request Payload】
   {
     "code": "wx_code_123",
     "userInfo": {
       "nickName": "张三",
       "avatarUrl": "https://..."
     }
   }
   ```
   
   4.3 验证响应数据：
   检查:
   - [ ] 响应状态码正确
   - [ ] 响应体结构符合契约
   - [ ] 字段类型正确
   - [ ] 前端能正确解析
   
   示例输出：
   ```
   【Response】
   Status: 200 OK
   {
     "code": 0,
     "data": {
       "access_token": "eyJhbGc...",
       "refresh_token": "eyJhbGc...",
       "user": {
         "userId": "123",
         "userName": "张三"
       }
     },
     "message": "success"
   }
   
   【前端解析】
   ✅ access_token 已存入 localStorage
   ✅ user 数据已存入 Store
   ✅ 页面跳转成功
   ```

5. 认证流程测试（如适用）：
   - [ ] Token 正确存储到 localStorage
   - [ ] 后续请求自动携带 Authorization 头
   - [ ] Token 过期后自动刷新
   - [ ] 刷新失败后跳转登录页
   
   验证方法：
   ```typescript
   // 1. 登录后检查 Storage
   console.log(localStorage.getItem('access_token')); // ✅ 应该存在
   
   // 2. 发起需要认证的请求，检查 Network 面板
   // Authorization: Bearer eyJhbGc... ✅
   
   // 3. 模拟 Token 过期
   localStorage.setItem('access_token', 'invalid_token');
   // 发起请求，应该触发刷新逻辑或跳转登录
   ```

6. 错误处理测试：
   - [ ] 400 错误: 显示参数错误提示
   - [ ] 401 错误: 跳转登录页
   - [ ] 403 错误: 显示权限提示
   - [ ] 500 错误: 显示通用错误提示
   - [ ] 网络错误: 显示网络错误提示
   
   验证方法：
   ```typescript
   // 模拟各种错误场景
   // 1. 断网测试：关闭网络，执行操作
   // 2. 401 测试：使用无效 Token
   // 3. 500 测试：后端故意返回错误
   ```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.3 集成测试】⭐ 必做

7. 完整业务流程测试：
   - [ ] 前端调用真实后端接口
   - [ ] 数据正确显示在界面上
   - [ ] 用户操作得到正确反馈
   - [ ] 数据已持久化到数据库
   
   验证方法：
   ```sql
   -- 在数据库中验证数据已保存
   SELECT * FROM users WHERE id = '123';
   SELECT * FROM diet_logs WHERE user_id = '123';
   ```

8. 数据流转验证：
   - [ ] 创建操作：数据已保存，界面显示新数据
   - [ ] 查询操作：数据正确显示
   - [ ] 更新操作：数据已更新，界面刷新
   - [ ] 删除操作：数据已删除，界面移除

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.4 UI/UX 测试】

9. 视觉还原度检查：
   - 对比 HTML 原型
   - 检查布局、颜色、字体、间距
   - 评估还原度（目标 ≥ 90%）

10. 响应式适配测试：
   - 桌面端（1920x1080）
   - 平板（768x1024）
   - 手机（375x667）

11. 交互体验测试：
   - 点击反馈
   - 加载状态
   - 错误提示
   - 表单验证

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.5 性能测试】

12. 测试性能指标：
    - 页面加载时间（目标 < 2s）
    - 接口响应时间（目标 < 1s）
   - 内存占用

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.6 回归测试】

13. 验证 T5 中识别的风险点
14. 测试关联功能是否受影响

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.7 联调问题记录】⭐ 必做

15. 记录所有联调问题：
    - 问题描述
    - 严重程度（🔴 阻塞 / 🟡 重要 / 🟢 轻微）
    - 根本原因
    - 解决方案
    - 责任方（前端/后端/双方）
    - 状态（✅ 已解决 / 🏃 处理中）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【7.8 生成报告】

16. 填写 T7_测试报告.md，包括：
    - 测试环境信息（包含后端地址）⭐
    - 单元测试用例和结果
    - 接口联调测试结果（包含 Network 截图）⭐
    - 集成测试结果 ⭐
    - 联调问题记录 ⭐
    - UI/UX 测试结果
    - 性能数据
    - 测试结论

17. 保存并更新看板 T7 列为 ✅

18. 如果发现阻塞性问题，标记看板为 🔴 并返回 T6 修复

19. 完成后，输出测试摘要和问题清单。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ 重要提示：
1. 前端任务必须完成接口联调测试，不可跳过
2. 如果后端接口未完成，可以先使用 Mock 数据完成单元测试
3. 等后端接口完成后，必须切换到真实接口并重新测试
4. 所有联调问题都要详细记录
5. 参考 docs/templates/前后端联调检查清单.md 进行全面检查
```

---

### 4.3 执行 T7 自动化联调测试（Gemini CLI 专用）🤖 推荐

```
执行任务 {task_id} 的 T7 自动化联调测试：

【完整提示词请参考】
docs/templates/T7_Gemini_CLI_自动化提示词.md

【核心流程】
1. 环境检查 → 2. 启动服务 → 3. 读取接口规约 → 4. 执行测试 
→ 5. 验证响应 → 6. 问题诊断 → 7. 自动修复 → 8. 重启重试 
→ 9. 生成报告

【AI 能力要求】
✅ 直接执行命令行命令（lsof, curl, grep, tail 等）
✅ 读取和修改文件（cat, 文件编辑）
✅ 分析日志输出
✅ 自动诊断问题
✅ 自动修复代码
✅ 生成测试报告

【快速开始】
复制以下命令开始执行：

gemini "执行任务 {task_id} 的 T7 自动化联调测试，
任务名称: {task_name}，
任务类型: 后端/前端，
请参考 docs/templates/T7_Gemini_CLI_自动化提示词.md 完整执行"
```

---

### 4.4 执行 T7 测试（快速版 - P2任务）

```
执行 P2 任务 {task_id} 的 T7 快速测试：

1. 启动服务
2. 执行基本接口测试
3. 如无阻塞性问题，直接进入 T9 交付

跳过详细的测试报告生成。
```

### 4.2 执行 T7 测试（快速版 - P2任务）

```
执行 P2 任务 {task_id} 的快速测试：

1. 执行基本功能测试
2. 记录主要测试结果
3. 如无阻塞性问题，直接进入 T9 交付

跳过详细的测试报告生成。
```

---

## 🔍 阶段 5: T8 代码审计

### 5.1 执行 T8 审计

```
执行任务 {task_id} 的 T8 审计阶段：

**审计准备**：
1. 读取 T6_变更清单.md 获取变更文件列表
2. 读取 docs/init_docs/编码规范.md

**规范审计**：
1. 命名规范检查：
   - 类名、方法名、变量名、常量名
   - 文件名、组件名

2. 代码格式检查：
   - 缩进、分号、引号
   - 空行、行长度

3. 注释完整性检查：
   - 类注释、方法注释
   - 复杂逻辑注释
   - TODO 标记

**质量审计**：
4. 后端代码质量（如适用）：
   - Controller 层职责
   - Service 层业务逻辑
   - Repository/Entity 层设计

5. 前端代码质量（如适用）：
   - 组件设计
   - 状态管理
   - 样式实现

**性能审计**：
6. 后端性能（如适用）：
   - 数据库查询优化
   - N+1 问题检查
   - 业务逻辑效率

7. 前端性能（如适用）：
   - 渲染性能
   - 资源加载
   - 内存管理

**安全审计**：
8. 输入验证
9. SQL 注入防护
10. XSS 防护
11. 权限控制
12. 敏感信息保护

**视觉审计**（前端任务）：
13. DOM 结构对比
14. 样式还原度
15. 响应式适配
16. 主题变量使用

**生成报告**：
17. 填写 T8_审计报告.md，包括：
    - 规范审计结果
    - 质量审计结果
    - 性能审计结果
    - 安全审计结果
    - 视觉审计结果（前端）
    - 审计评分
    - 优化建议

18. 保存并更新看板 T8 列为 ✅

19. 完成后，输出审计摘要和评分。
```

---

## 👁️ 阶段 6: T8.5 代码审查

### 6.1 执行 T8.5 审查

```
执行任务 {task_id} 的 T8.5 代码审查阶段：

**审查准备**：
1. 读取所有前置文档：
   - T5_分析文档.md
   - T6_变更清单.md
   - T7_测试报告.md
   - T8_审计报告.md
2. 读取架构设计文档和接口规约

**逻辑正确性审查**：
1. 业务逻辑一致性：
   - 是否符合 T5 分析文档的业务流程
   - 数据流转逻辑是否正确

2. 边界条件处理：
   - 空值、边界值、特殊情况

3. 异常处理：
   - Try-Catch 使用
   - 错误传播
   - 错误日志

4. 并发与竞态：
   - 并发安全
   - 竞态条件
   - 事务完整性

**架构与设计审查**：
5. 分层架构一致性：
   - 是否违反分层原则
   - 职责是否清晰

6. 设计模式应用：
   - 依赖注入
   - 设计模式使用

7. 代码复用性：
   - 是否有重复代码
   - 公共逻辑是否提取

8. 接口设计：
   - 接口职责
   - 参数设计
   - RESTful 规范

**可读性与可维护性**：
9. 命名语义化
10. 注释质量
11. 函数复杂度
12. 代码结构

**性能与优化**：
13. 数据库性能（后端）
14. 算法效率
15. 前端性能（前端）
16. 内存管理

**UI/UX 审查**（前端）：
17. 视觉一致性
18. 交互体验
19. 响应式设计
20. 无障碍性

**安全性审查**：
21. 输入验证
22. 权限控制
23. 敏感信息保护

**技术债务标记**：
24. 识别技术债务
25. 标记临时方案
26. 记录待优化项

**生成审查意见**：
27. 填写 T8.5_审查意见.md，包括：
    - 总体评价
    - 问题统计
    - 必需修改项（Must Fix）
    - 建议修改项（Suggestions）
    - 优秀实践（Good Practices）
    - 技术债务标记
    - 最终决定（Pass / Pass with Comments / Changes Requested）

28. 保存并更新看板：
    - 如果通过：T8.5 列为 ✅
    - 如果驳回：T8.5 列为 ↩️

29. 完成后，输出审查结论和关键问题。
```

---

## 🚀 阶段 7: T9 功能交付

### 7.1 执行 T9 交付

```
执行任务 {task_id} 的 T9 交付阶段：

**交付前检查**：
1. 确认 T5-T8.5 全部完成且通过
2. 确认无阻塞性问题

**Git 提交**：
3. 生成 Commit Message（格式）：
   <type>(<scope>): <subject> (#任务ID)
   
   示例：
   feat(auth): 实现微信登录认证接口 (#U-1)
   
   - 新增 AuthModule、AuthController、AuthService
   - 实现 JWT 策略和守卫
   - Mock 微信 API 调用逻辑
   
   Reviewed-by: AI Assistant

4. 执行 Git 操作：
   git add .
   git commit -m "[生成的 commit message]"
   git push origin [分支名]

**更新看板**：
5. 在 docs/pj_docs/04.5_原子任务交付看板.md 中：
   - 将任务 {task_id} 的 T9 列更新为 ✅
   - 将"进度"列更新为 100%
   - 如有技术债，在"状态"列标记 ⚠️

**归档文档**：
6. 确认所有文档已保存：
   - T5_分析文档.md
   - T6_变更清单.md
   - T7_测试报告.md
   - T8_审计报告.md
   - T8.5_审查意见.md

**完成通知**：
7. 输出交付摘要：
   - 任务ID和名称
   - Git commit hash
   - 完成时间
   - 实际工时 vs 预估工时
   - 技术债务（如有）

8. 建议下一个任务。
```

---

## 📊 进度管理

### 8.1 生成每日进度报告

```
生成今天（{date}）的开发日报：

1. 读取 docs/pj_docs/04.5_原子任务交付看板.md

2. 统计今日完成情况：
   - 今日完成的任务列表
   - 今日进行中的任务
   - 今日计划但未完成的任务

3. 工时统计：
   - 计划工时 vs 实际工时
   - 效率分析

4. 问题记录：
   - 遇到的问题
   - 解决方案
   - 待解决问题

5. 明日计划：
   - 计划完成的任务
   - 预估工时

6. 生成报告并保存到：docs/reports/daily_{date}.md

7. 输出报告摘要。
```

### 8.2 生成每周进度报告

```
生成本周的开发周报：

1. 读取看板，统计本周完成情况

2. 生成周报，包括：
   - 本周完成任务统计（按优先级、按域）
   - 工时统计和效率分析
   - 里程碑达成情况
   - 本周亮点
   - 问题与风险
   - 技术债务
   - 下周计划
   - 趋势分析
   - 经验总结

3. 保存到：docs/reports/weekly_{week}.md

4. 输出周报摘要。
```

### 8.3 更新看板状态

```
更新任务 {task_id} 的看板状态：

1. 打开 docs/pj_docs/04.5_原子任务交付看板.md

2. 找到任务 {task_id} 对应的行

3. 更新指定阶段的状态：
   - 阶段: {stage} (T5/T6/T7/T8/T8.5/T9)
   - 状态: {status} (✅/🏃/📅/⚠️/↩️/⛔)

4. 如果是 T9 阶段完成，同时更新"进度"列为 100%

5. 保存文件

6. 确认更新成功。
```

---

## 🔄 特殊场景

### 9.1 处理测试失败

```
任务 {task_id} 的 T7 测试失败，需要返工：

1. 在 T7_测试报告.md 中详细记录失败原因

2. 更新看板：
   - T7 列标记为 🔴（阻塞）
   - 在"阻塞源"列说明原因

3. 分析失败原因，确定需要修改的代码

4. 返回 T6 阶段修复代码

5. 修复完成后，重新执行 T7-T9

6. 在 T6_变更清单.md 中记录修复内容

7. 输出修复摘要。
```

### 9.2 处理审查驳回

```
任务 {task_id} 的 T8.5 审查不通过：

1. 在 T8.5_审查意见.md 中查看驳回原因

2. 更新看板：
   - T8.5 列标记为 ↩️（已驳回）

3. 根据审查意见修改代码

4. 修改完成后，重新执行 T7-T9

5. 在 T6_变更清单.md 中记录修改内容

6. 输出修复摘要。
```

### 9.3 标记技术债务

```
为任务 {task_id} 标记技术债务：

1. 在 T8.5_审查意见.md 的"技术债务标记"部分记录：
   - 技术债描述
   - 产生原因
   - 影响范围
   - 计划清理时间
   - 优先级

2. 更新看板：
   - 在"状态"列标记 ⚠️
   - 在备注中说明技术债

3. 创建技术债清理任务（可选）

4. 输出技术债摘要。
```

### 9.4 并行执行多个任务

```
并行执行以下任务：

任务列表：
- {task_id_1}: {task_name_1}
- {task_id_2}: {task_name_2}
- {task_id_3}: {task_name_3}

执行策略：
1. 确认这些任务之间无依赖关系
2. 为每个任务创建独立的工作目录
3. 按照标准流程并行执行 T5-T9
4. 分别更新看板
5. 输出所有任务的完成摘要

请高效地并行处理这些任务。
```

---

## 💡 快捷指令

### 10.1 一键执行完整任务

```
一键执行任务 {task_id} 的完整开发流程：

任务信息：
- 任务ID: {task_id}
- 任务名称: {task_name}
- 优先级: {priority}

请按照任务清单 v4.0 的标准流程，依次执行：
1. T5 分析
2. T6 编码
3. T7 测试
4. T8 审计
5. T8.5 审查
6. T9 交付

每个阶段完成后，输出简要摘要。
全部完成后，输出最终交付报告。
```

### 10.2 快速完成 P2 任务

```
快速完成 P2 任务 {task_id}（简化流程）：

1. T5 快速分析（30分钟）
2. T6 编码实现
3. T9 快速交付（跳过 T7/T8/T8.5）

请在最短时间内完成该任务。
```

### 10.3 批量初始化任务

```
批量初始化以下任务：

任务列表：
- U-3: 构建登录页面 UI
- U-4: 开发登录按钮和隐私政策弹窗组件
- U-5: 实现前端路由守卫

请为每个任务创建工作目录和文档模板。
```

---

## 📚 参考资料

### 相关文档
- `任务清单_v4.0_优化版.md`: 主任务清单
- `docs/pj_docs/02_需求原子化拆分.md`: 所有任务定义
- `docs/pj_docs/04.5_原子任务交付看板.md`: 进度追踪
- `docs/templates/`: 所有文档模板

### 使用技巧
1. 复制提示词后，替换 `{占位符}` 为实际值
2. 可以根据实际情况调整提示词内容
3. 对于复杂任务，建议分阶段执行
4. 对于简单任务，可以使用一键执行

---

**版本**: v1.0  
**最后更新**: 2026-01-27  
**适用于**: Gemini CLI + 任务清单 v4.0

