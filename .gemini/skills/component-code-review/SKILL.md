1. 场景定位 (Where & Speciality)
   审计重点：它在哪用？有什么脾气？

通用基础件（如 Button/Modal）： 特殊性在于“牵一发而动全身”。审计重点是样式污染（是否写死了颜色、边距）和属性透传。

业务逻辑件（如 UserList/OrderCard）： 特殊性在于“环境依赖”。审计重点是它是否强耦合了某个 Global Store (Redux/Pinia) 或特定的 API 结构，导致换个页面就报错。

列出所有使用场景（比如：这个组件在订单页、用户页都被用到了），分析它在不同场景下的表现和适应性。

2. 输入与输出 (I/O)
   审计重点：数据进来干不干净？出去准不准？

输入 (Props)：

是否有必填项校验？（防止因为 data.list 是 undefined 导致页面白屏）。

是否有冗余传参？（传了 20 个 Props 进来，结果只用了 3 个）。

输出 (Events)：

回调函数的参数格式是否固定？（不要一会儿返回 ID，一会儿返回整个 Object）。

是否处理了异步反馈？（点提交按钮后，有没有 Loading 状态吐出来）。

3. 主要功能 (Core Function)
   审计重点：它宣称的功能实现了吗？边界情况呢？

核心链路： 这个组件的“主线任务”是什么？（例如：搜索框的主要功能是触发搜索）。

异常处理： 如果接口断了、数据空了、图片加载失败了，组件是否有降级显示？（比如：显示“暂无数据”占位图）。

交互闭环： 操作完之后，用户能否得到明确的视觉反馈？

4. 逻辑合规性 (Logic Correctness)
   审计重点：脑子清不清晰？有没有“骚操作”？

单向流： 有没有在组件内部偷偷修改 props？（这是禁忌，数据必须由父组件控制）。

计算属性： 那些能通过 props 计算出来的数据，是不是又开了一个 state 来存？（这会导致数据不同步）。

内存卫生： 开启的定时器（Timer）或监听器（Event Listener）在组件关掉时销毁了吗？
