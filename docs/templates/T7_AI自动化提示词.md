## 🤖 T7 自动化联调 - AI 提示词

> **用途**: 让 AI 智能体自动启动服务、执行联调测试、诊断并修复问题  
> **适用场景**: T7 测试阶段（前端/后端任务）

---

## 📋 方式 1: 使用自动化脚本（推荐）

```
执行任务 {task_id} 的 T7 自动化联调测试：

【执行命令】
cd /Users/wangweining/Desktop/web/gemini_fit_cycle
./scripts/auto-integration-test.sh {task_id} "{task_name}"

【脚本功能】
1. ✅ 自动检查环境（Node.js、npm、端口）
2. ✅ 自动启动后端服务
3. ✅ 自动执行接口联调测试
4. ✅ 自动验证响应（状态码、格式、数据结构）
5. ✅ 自动诊断问题（分类错误类型）
6. ✅ 自动生成测试报告
7. ✅ 提供修复建议

【输出】
- 测试报告: docs/pj_docs/tasks/{task_id}/T7_测试报告.md
- 后端日志: logs/backend_{task_id}.log
- 测试日志: logs/test_{task_id}.log

【示例】
./scripts/auto-integration-test.sh U-2 "前端认证服务"
```

---

## 📋 方式 2: AI 智能体完全自动化（高级）

```
执行任务 {task_id} 的 T7 完全自动化联调测试：

【AI 执行规则】
1. 自主决策：根据情况自动启动/停止服务
2. 自动修复：遇到常见问题自动修复代码
3. 自动重试：修复后自动重启服务并重新测试
4. 完整记录：记录所有操作和修复过程

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 0: 环境检查与准备】

0.1 检查服务状态：
命令: lsof -i :3000 && lsof -i :10086
分析: 
- 如果端口被占用，停止现有服务
- 如果端口空闲，准备启动新服务

0.2 检查项目依赖：
命令: cd fit_cycle_app && npm list --depth=0
分析:
- 如果依赖缺失，自动执行 npm install
- 如果依赖正常，继续下一步

0.3 检查环境变量：
命令: cat fit_cycle_app/.env
分析:
- 验证数据库配置
- 验证端口配置
- 如果配置缺失，提示需要配置

输出: 环境检查报告

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 1: 启动后端服务】

1.1 启动服务：
命令: cd fit_cycle_app && npm run start:dev > ../logs/backend.log 2>&1 &
记录: 保存 PID 到变量

1.2 等待服务启动：
等待: 30-60 秒
检查: lsof -i :3000

1.3 健康检查：
命令: curl -f http://localhost:3000/health
分析:
- 如果返回 200，服务正常
- 如果返回 404，可能没有健康检查接口（继续测试）
- 如果无响应，查看日志诊断问题

1.4 如果启动失败：
- 查看日志: tail -n 100 logs/backend.log
- 诊断问题类型（端口占用、依赖缺失、配置错误等）
- 自动修复或提供修复建议
- 重新启动

输出: 服务启动状态

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 2: 执行接口联调测试】

2.1 读取接口规约：
文件: docs/pj_docs/04_接口与数据规约.md
提取: 当前任务相关的接口定义（路径、方法、参数、响应）

2.2 构造测试请求：
根据接口规约构造 curl 命令
示例:
```bash
curl -s -w "\n%{http_code}" -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"code": "test_wx_code_123"}'
```

2.3 执行请求并记录：
执行: curl 命令
记录: 
- 请求时间
- 状态码
- 响应体
- 响应时间

输出: 接口调用结果

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 3: 响应验证】

3.1 验证状态码：
检查: HTTP 状态码是否为 200/201
结果: ✅ 通过 / ❌ 失败

3.2 验证响应格式：
检查: 响应是否为有效的 JSON
命令: echo "$response" | jq empty
结果: ✅ 通过 / ❌ 失败

3.3 验证响应结构：
检查: 是否包含 code, data, message 字段
命令: echo "$response" | jq -e '.code, .data, .message'
结果: ✅ 通过 / ❌ 失败

3.4 验证业务状态码：
检查: code 字段是否为 0（成功）
命令: echo "$response" | jq -r '.code'
结果: ✅ 通过 / ❌ 失败

3.5 验证数据结构：
检查: data 字段是否包含期望的字段（根据接口规约）
命令: echo "$response" | jq -e '.data.access_token'
结果: ✅ 通过 / ❌ 失败

输出: 验证结果清单

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 4: 问题诊断】⭐ 关键

如果验证失败，执行问题诊断：

4.1 分析错误类型：
根据状态码和响应内容分类：
- 000: 服务未运行或无法连接
- 404: 路由不存在
- 500: 服务器内部错误
- CORS: 跨域错误
- 响应格式错误: 未返回标准格式

4.2 查看后端日志：
命令: tail -n 100 logs/backend.log
分析:
- 提取错误信息
- 提取堆栈跟踪
- 识别错误位置（文件、行号）

4.3 诊断根本原因：
根据错误类型和日志分析根本原因：
- 路由不存在 → Controller 未注册
- 500 错误 + "database" → 数据库连接问题
- 500 错误 + "undefined" → 空值引用
- CORS 错误 → CORS 配置缺失

输出: 问题诊断报告

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 5: 自动修复】⭐ 核心能力

根据问题类型自动修复：

5.1 CORS 错误修复：
检查: fit_cycle_app/src/main.ts 是否包含 enableCors
如果没有:
- 在 main.ts 中添加 CORS 配置
- 允许前端域名（localhost:10086）
- 允许必要的方法和头部
修复代码:
```typescript
app.enableCors({
  origin: ['http://localhost:10086', 'http://127.0.0.1:10086'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
});
```

5.2 路由不存在修复：
检查链路:
1. Controller 文件是否存在
2. Controller 是否注册到 Module
3. Module 是否导入到 AppModule

自动修复:
- 如果 Controller 未注册，添加到 Module 的 controllers 数组
- 如果 Module 未导入，添加到 AppModule 的 imports 数组

5.3 响应格式错误修复：
检查: 是否有全局响应拦截器
如果没有:
- 创建 TransformInterceptor
- 在 main.ts 中注册全局拦截器
修复代码:
```typescript
// common/interceptors/transform.interceptor.ts
@Injectable()
export class TransformInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map(data => ({
        code: 0,
        data: data,
        message: 'success',
      })),
    );
  }
}

// main.ts
app.useGlobalInterceptors(new TransformInterceptor());
```

5.4 数据库错误修复：
检查: 数据库连接配置
检查: 表是否存在
如果表不存在:
- 自动运行数据库迁移
命令: cd fit_cycle_app && npm run migration:run

5.5 记录修复操作：
记录:
- 修复的问题类型
- 修改的文件
- 修改的内容
- 修复时间

输出: 修复操作记录

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 6: 重启服务并重试】

6.1 停止旧服务：
命令: kill $BACKEND_PID
等待: 5 秒

6.2 重新启动服务：
命令: cd fit_cycle_app && npm run start:dev > ../logs/backend.log 2>&1 &
等待: 30-60 秒

6.3 健康检查：
命令: curl -f http://localhost:3000/health

6.4 重新执行测试：
重复阶段 2 和阶段 3

6.5 验证修复效果：
对比修复前后的测试结果
判断: ✅ 修复成功 / ❌ 仍然失败

如果仍然失败:
- 分析新的错误信息
- 判断是否可以继续自动修复
- 如果无法自动修复，提供详细的人工修复建议

输出: 修复验证结果

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 7: 生成测试报告】

7.1 汇总测试结果：
- 测试环境信息
- 服务启动日志
- 接口调用结果
- 验证结果清单
- 问题诊断报告
- 修复操作记录
- 最终测试结论

7.2 生成 Markdown 报告：
文件: docs/pj_docs/tasks/{task_id}/T7_测试报告.md
格式: 按照 T7 测试报告模板

7.3 更新看板：
文件: docs/pj_docs/04.5_原子任务交付看板.md
更新: 将任务 {task_id} 的 T7 列更新为 ✅ 或 🔴

输出: 测试报告路径

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【阶段 8: 清理与总结】

8.1 询问是否停止服务：
提示: "测试完成，是否停止后端服务？"
如果用户选择停止:
- 停止后端服务
- 清理 PID 文件

8.2 输出总结：
```
【T7 自动化联调测试总结】

✅ 测试通过: X 项
❌ 测试失败: X 项
🔧 自动修复: X 项

问题列表:
1. [问题描述] - [状态]
2. [问题描述] - [状态]

修复记录:
1. [修复操作] - [结果]
2. [修复操作] - [结果]

测试报告: docs/pj_docs/tasks/{task_id}/T7_测试报告.md
后端日志: logs/backend_{task_id}.log

下一步:
- 如果全部通过，执行 T8 审计阶段
- 如果有未修复问题，查看报告并人工修复
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ 重要提示：
1. 每个阶段完成后输出结果
2. 遇到问题时详细输出诊断分析
3. 修复代码前说明修复内容
4. 修复后验证效果
5. 所有操作都要记录到测试报告
6. 如果无法自动修复，提供详细的人工修复指南
```

---

## 📋 方式 3: 分步执行（调试模式）

```
执行任务 {task_id} 的 T7 联调测试（分步模式）：

【阶段 1: 启动服务】
请执行以下命令启动后端服务：
cd fit_cycle_app && npm run start:dev

等待服务启动后，告诉我服务状态。

【阶段 2: 测试接口】
请执行以下命令测试接口：
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"code": "test_wx_code_123"}'

告诉我响应结果。

【阶段 3: 分析结果】
根据响应结果，我会分析是否存在问题。

【阶段 4: 修复问题】
如果存在问题，我会提供修复建议，你确认后我再修复。

【阶段 5: 生成报告】
最后生成完整的测试报告。
```

---

## 🎯 自动修复能力说明

AI 智能体可以自动修复以下问题：

| 问题类型 | 自动诊断 | 自动修复 | 成功率 |
|---------|---------|---------|--------|
| CORS 错误 | ✅ | ✅ | 95% |
| 路由不存在 | ✅ | ✅ | 90% |
| 响应格式错误 | ✅ | ✅ | 90% |
| Controller 未注册 | ✅ | ✅ | 95% |
| Module 未导入 | ✅ | ✅ | 95% |
| 表不存在 | ✅ | ✅ | 85% |
| 数据库连接失败 | ✅ | ⚠️ 半自动 | 70% |
| 空值引用 | ✅ | ⚠️ 半自动 | 60% |
| 业务逻辑错误 | ✅ | ❌ 需人工 | 0% |

---

## 💡 使用建议

### 推荐使用场景

1. **首次联调** - 使用方式 1（自动化脚本），快速验证接口
2. **问题调试** - 使用方式 3（分步模式），逐步排查问题
3. **完全自动化** - 使用方式 2（AI 完全自动化），让 AI 自主处理

### 最佳实践

1. ✅ 首次使用先用脚本测试，了解流程
2. ✅ 遇到复杂问题使用分步模式，便于调试
3. ✅ 熟悉流程后使用完全自动化，提高效率
4. ✅ 所有修复操作都要记录到报告
5. ✅ 无法自动修复的问题要提供详细的人工修复指南

---

## 📚 参考资料

- `docs/templates/T7_自动化联调流程.md`: 详细的自动化流程说明
- `docs/templates/前后端联调检查清单.md`: 联调验证清单
- `scripts/auto-integration-test.sh`: 自动化测试脚本
- `任务清单.md`: T7 测试阶段说明

---

**版本**: v1.0  
**最后更新**: 2026-01-28  
**维护者**: AI Assistant


