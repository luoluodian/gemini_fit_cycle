# T5 分析文档: R-3 餐次操作接口 (Meal Operations API) - V2 增强版

## 1. 任务背景 (Task Background)
任务 **R-3** 负责饮食记录明细的增删改。它是数据持久化的枢纽，必须确保每一笔录入都携带完整的营养素快照，并严密保护用户数据不被越权访问。

## 2. 接口契约分析 (Interface Contract)

### 2.1 添加记录 (Add Meal Log)
- **Endpoint**: `POST /records/meal`
- **Request Body**: `{ "date", "mealType", "foodId", "quantity" }`
- **逻辑**: 若当日总表不存在，先创建 `DailyRecord` 快照。

### 2.2 更新记录 (Update Meal Log)
- **Endpoint**: `PUT /records/meal/:id`
- **Request Body**: `{ "quantity", "mealType" }`
- **逻辑**: 根据新数量重新计算并覆盖 `calories`, `macros` 快照。

### 2.3 删除记录 (Delete Meal Log)
- **Endpoint**: `DELETE /records/meal/:id`

## 3. 核心业务逻辑 (Core Business Logic)

### 3.1 冗余鉴权架构 (Performance-First Security)
- 为了提升鉴权性能，在 `MealLog` 实体中增加 **`userId`** 冗余字段。
- 所有写操作（PUT/DELETE）必须在 SQL 层面强制带上 `WHERE id = :id AND userId = :userId`。

### 3.2 快照溯源逻辑
`MealLog` 不仅存储“最终摄入热量”，还需存储：
- `baseCalories`: 来源于 `FoodItem` 的 100g 基准热量。
- `foodName`: 食材实时名称。
- **目的**: 即使关联食材被物理删除，历史打卡记录的溯源计算逻辑依然透明、可追溯。

## 4. 数据一致性保障
- **事务处理**: `POST /meal` 中“创建总表”与“插入明细”必须包裹在同一事务内。
- **冲突策略**: 捕获 `DailyRecord` 的 `DuplicateKey` 错误，平滑降级为 `SELECT` 现有记录。

## 5. 潜在风险与对策 (Risks & Mitigations)
- **无效食材**: 验证 `foodId` 是否有效，禁止为已下架食材添加新记录。
- **负数防御**: `quantity` 必须 > 0，防止通过 API 构造负热量记录。

## 6. 结论 (Conclusion)
V2 版 T5 通过增加“改”接口和“冗余鉴权”字段，在保证业务完整性的同时，大幅提升了系统的响应速度与安全性。