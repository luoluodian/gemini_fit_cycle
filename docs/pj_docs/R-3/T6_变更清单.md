# T6 变更清单: R-3 餐次操作接口 (Meal Operations API)

## 1. 实体优化 (Entity Enhancements)

### 1.1 更新 `MealLog` 实体
- **文件**: `fit_cycle_app/src/database/entity/meal-log.entity.ts`
- **新增字段**:
    - `userId`: `bigint`, Not Null (冗余字段，用于高性能鉴权)。
    - `baseCalories`: `int` (记录食材每 100g 的热量快照)。
    - `baseProtein/baseFat/baseCarbs`: `decimal(10,4)` (营养素基准快照)。
- **关联策略**:
    - `foodItem`: 设置 `onDelete: 'SET NULL'`。
    - **索引**: 增加 `idx_user_record` (`userId`, `recordId`) 组合索引。

## 2. 后端变更清单 (Backend Changes)

### 2.1 控制层实现 (`records.controller.ts`)
- **POST `/meal`**:
    - Body: `CreateMealLogDto`
    - 逻辑: 调用 `service.addMealLog`。
- **PUT `/meal/:id`**:
    - Body: `UpdateMealLogDto` (仅含 `quantity`, `mealType`)
    - 逻辑: 调用 `service.updateMealLog`。
- **DELETE `/meal/:id`**:
    - 逻辑: 调用 `service.removeMealLog`。

### 2.2 服务层核心逻辑 (`records.service.ts`)
- **`addMealLog(userId, dto)`**:
    1. **开启事务**。
    2. 执行 `getOrCreateDailyRecord` (复用 R-2 逻辑，增加持久化动作)。
    3. 查询 `FoodItem` 详情，若不存在或状态无效则抛出 400。
    4. **计算快照**: 
        - `calories = food.calories * quantity / 100`。
        - 存储 `baseCalories` 及 `foodName` 等冗余信息。
    5. 保存并提交事务。
- **`updateMealLog(userId, id, dto)`**:
    1. 鉴权: 检查记录是否存在且 `userId` 匹配。
    2. 重新加载 `baseCalories` 快照（若 DTO 仅含 quantity）。
    3. **重算营养素**: 基于 `base` 字段计算新摄入量对应的热量。
    4. 更新并返回。
- **`removeMealLog(userId, id)`**:
    1. 鉴权并执行物理删除（`deletedAt` 软删除也可，视项目习惯）。

### 2.3 DTO 验证
- 使用 `class-validator`:
    - `quantity`: `@IsPositive()` (必须 > 0)。
    - `mealType`: `@IsEnum(MealType)`。

## 3. 数据一致性处理
- 事务封装: 确保在创建 `DailyRecord` 的瞬间，关联的第一个 `MealLog` 必须落库成功，否则整体回滚。

## 4. 验证计划 (Verification)
- **快照独立性测试**:
    - [ ] 添加食物 A (热量 100)。
    - [ ] 修改食材库中 A 的热量为 200。
    - [ ] 验证历史 `MealLog` 中的热量依然为 100 (证明快照有效)。
- **越权测试**:
    - [ ] 使用 User B 的 Token 尝试删除 User A 的 `meal_log`，验证是否返回 403/404。
- **并发测试**:
    - [ ] 模拟同一秒内两次 POST 请求，验证数据库中是否仅有一条 `daily_records`。

## 5. 依赖
- 依赖 `FoodItemModule` 提供食材查询服务。
- 依赖 `DietRecordsModule` 内部的事务管理器。
