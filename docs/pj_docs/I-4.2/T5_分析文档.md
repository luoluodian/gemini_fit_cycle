# T5 分析文档: I-4.2 响应式 Store 联动 (Reactive Linkage)

## 1. 任务背景 (Task Background)
任务 **I-4.2** 旨在验证 fit_cycle 记录域的“响应式内核”。在 I-4.1 打通保存链路后，本任务需确保前端 Store 具备即时重算能力，让用户感知的热量变化与后端落库状态实现秒级同步。

## 2. 响应式传导链审计 (Reactivity Chain)

### 2.1 数据流向
1.  **Source**: `recordStore.mealLogs` (由 `addMealLogAction` 或 `syncMealFromPlan` 更新)。
2.  **Trigger**: Vue 3 响应式追踪探测到数组引用变化。
3.  **Intermediate**: `recordSummary` (Getter) 重新执行 `reduce`。
4.  **Terminal**: `displaySummary` 和 `achievementRatios` 同步计算出最新百分比。
5.  **View**: `DailyGoalsOverview` 进度条宽度样式响应式更新。

### 2.2 逻辑一致性校验
- **目标**: 验证在不调用 `fetchRecord` 的情况下，仅凭 `mealLogs` 的局部 push，进度环显示的“已摄入热量”是否能准确增长。
- **难点**: 确保 `targetCalories` 快照不会因为局部更新而丢失。

## 3. 联调重点 (Integration Focus)

### 3.1 跨组件感知
- 验证 `HomeMealCard` 内部的删除动作成功后，`recordStore` 的变动是否能跨组件通知到首页头部的 `DailyGoalsOverview`。

### 3.2 性能边界
- 审计是否存在“过度渲染”：即单一餐次的增删，是否导致了不相关的其它餐次卡片（MealCard）执行重绘。

## 4. 验证计划 (Verification)

- **实时计算验证**:
    - [ ] 在首页添加 500kcal 食物，观察进度条长度是否立即改变。
- **删除联动验证**:
    - [ ] 在首页删除 200kcal 食物，验证总热量数值是否立即扣除。
- **精度一致性**:
    - [ ] 对比 Store 内部数值与 UI 展示字符串，确保无“.0000001”碎屑残留。

## 5. 潜在风险与对策 (Risks & Mitigations)
- **数组变异陷阱**: Pinia/Vue3 对 `push` 可能无法追踪。需确保 Action 中使用 `this.mealLogs = [...this.mealLogs, newLog]` 的非变异赋值。
- **异步竞争**: 若 `fetchRecord` (全量) 与 `addMealLogAction` (局部) 同时发生，验证是否存在状态覆盖风险。

## 6. 结论 (Conclusion)
I-4.2 的成功标志着应用具备了真正的“动态交互感”。通过验证响应式联动，我们确立了以数据状态驱动 UI 的核心工程模式，为后续复杂的营养分析奠定了基础。
