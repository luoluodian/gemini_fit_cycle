# U-1: 微信登录接口 - T5 分析文档

> **任务 ID**: U-1
> **任务名称**: 微信登录接口
> **优先级**: P0
> **垂直拆分**: 后端 API / 认证服务
> **预估工时**: 2h
> **复杂度**: 中
> **分析时间**: 2026-01-31
> **分析人**: AI Assistant

---

## 5.1 模块关联性审计

### 涉及公共数据表
- [x] `users` (`fit_cycle_app/src/database/entity/user.entity.ts`): 需要存储 `openid`, `nickname`, `avatar_url`。
- [x] `health_profiles` (关联表): U-1 暂时只创建基础用户记录，健康档案可能在 U-7 处理，但需确认是否需要在注册时初始化空记录。

### 涉及公共组件
- [x] `AuthService` (`fit_cycle_app/src/modules/auth/auth.service.ts`): 核心业务逻辑。
- [x] `AuthController` (`fit_cycle_app/src/modules/auth/auth.controller.ts`): API 入口。
- [x] `UserResponseDto` (`fit_cycle_app/src/dtos/auth-response.dto.ts`): 响应数据结构。

### 涉及跨模块 Service
- [x] `UserService` (`fit_cycle_app/src/modules/user/user.service.ts`): `AuthService` 依赖 `UserService` 进行用户的查找和创建。

### 所有关联模块
- `UserModule`, `ConfigModule` (获取 WeChat AppID/Secret), `JwtModule`.

---

## 5.2 影响评估

### 需要修改的现有文件
- [x] `fit_cycle_app/src/modules/auth/auth.service.ts`: 
    - 现有的 `wechatAuth` 方法已经实现了基础逻辑，但需确认 `findOrCreateByOpenid` 的实现细节。
    - 需确认是否需要在注册时同步创建 `health_profiles` 记录（根据规约 S-1 分析，健康档案是独立表）。
- [x] `fit_cycle_app/src/modules/user/user.service.ts`:
    - 需审查 `findOrCreateByOpenid` 是否正确处理了事务。

### 对现有功能的影响
- **有影响**: 任何对认证逻辑的修改都可能影响全站 API 的访问（依赖 Token）。

### 必须参考的文件路径
- `docs/pj_docs/04_接口与数据规约.md`: "2.1 认证 (Auth)" 接口定义。

### 潜在的破坏性变更
- **无破坏性变更**: 目前是初始化阶段，代码主要是在完善而非重构。

---

## 5.3 技术落地计划

### 1. 文件创建清单
无新文件，主要是逻辑完善。

### 2. 代码审计与修正点

#### 后端方法 (`AuthService.wechatAuth`)
- **现状**:
  ```typescript
  let user = await this.userService.findOrCreateByOpenid(openid);
  // ... 更新 nickname/avatar ...
  user.refreshToken = refreshToken;
  await this.userService.userRepository.save(user);
  ```
- **修正目标**: 
  - 逻辑基本正确。
  - **关键点**: 确认 `refreshToken` 的存储是否安全（数据库中是否明文？JWT 签名是否使用了独立的 Secret？）。根据代码，使用了 `JWT_REFRESH_SECRET`，是安全的。
  - **缺失**: 注册新用户时，是否应该初始化 `HealthProfile`？根据业务逻辑，用户注册后通常会引导填写资料，因此可以暂不创建，或者创建一个默认空的。建议保持现状，在 U-7 填写资料时创建。

#### 后端方法 (`UserService.findOrCreateByOpenid`)
- **现状**:
  ```typescript
  async findOrCreateByOpenid(openId: string): Promise<User> {
    let user = await this.userRepository.findOne({ where: { openId } });
    if (!user) {
      user = this.userRepository.create({ openId });
      await this.userRepository.save(user);
    }
    return user;
  }
  ```
- **修正目标**: 逻辑正确。但需注意并发注册时的 Race Condition（唯一索引冲突）。`initial-schema.sql` 中 `openid` 已设为 Unique Key，所以数据库层会报错。代码层面可以加一个 `try-catch` 重试，或者简单依赖数据库报错（由 `HttpExceptionFilter` 捕获）。当前阶段可暂不处理高并发冲突。

### 3. 数据流向
```
Client (WeChat Mini Program) -> POST /auth/wechatAuth ({ code }) 
-> AuthController -> AuthService -> WeChat API (jscode2session) 
-> UserService (Find/Create User) 
-> AuthService (Sign JWT) 
-> Client ({ token, user })
```

### 5. 依赖任务检查
- [x] 依赖任务 `S-1` 已完成 (数据库表结构就绪)。
- [x] 依赖任务 `S-2` 已完成 (响应拦截器就绪)。

---

## 5.4 风险点清单

### 技术风险
- [x] **WeChat API 超时**: `axios` 请求已设置 timeout，需确保超时后有友好的错误提示。
- [x] **Session Key 安全**: 后端目前未存储 `session_key`，这是正确的（仅用于解密数据，用完即焚）。

---

## 5.5 预期交付物

### 代码交付物
- 无需大幅修改代码，主要是验证和微调。

### 文档交付物
- `docs/pj_docs/U-1/U-1_分析文档.md`

---

## 5.6 自检清单

- [x] 所有关联模块已识别
- [x] 所有影响范围已评估
- [x] 技术方案可行且清晰
- [x] 数据流向已明确

---

## 5.7 下一步行动

1. **立即执行**: 
   - 运行 `npm run test:e2e` 再次验证 `auth.e2e-spec.ts`，确保 S-1 数据库变更后认证逻辑依然跑通。
2. **需要澄清**: 无。
