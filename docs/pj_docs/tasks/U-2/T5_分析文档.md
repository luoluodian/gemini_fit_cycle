# U-2: 前端认证服务 - T5 分析文档

## 5.1 模块关联性审计

- **涉及公共 Store**: `useUserStore` (Pinia)
- **涉及公共组件**: 无 (纯逻辑/Service)
- **涉及跨模块 Service**:
  - `fit_cycle_web/src/services/http/interceptors.ts`: 处理 Token 刷新逻辑。
  - `fit_cycle_web/src/services/modules/auth.ts`: 定义登录 API 请求。
- **涉及外部依赖**:
  - `Taro`: 原生 API (`Taro.request`, `Taro.reLaunch`)。
  - `Pinia`: 状态管理。

## 5.2 影响评估

- **需要修改的现有文件**:
  - `fit_cycle_web/src/services/http/interceptors.ts`: 修正 Token 刷新时的 Storage Key (目前与 `user.ts` store 不统一)。
  - `fit_cycle_web/src/services/modules/user.ts`: 定义或修正 `refreshToken` 方法。
  - `fit_cycle_web/src/constants/api-config.ts`: 更新 `AUTH_ROUTES` 以包含后端的新接口路径。
- **对现有功能的影响**: 影响所有需要认证的接口调用及 Token 续期机制。
- **必须参考的文件路径**:
  - `docs/pj_docs/04_接口与数据规约.md`: 后端 `/auth/wechatAuth` 接口契约。
  - `fit_cycle_web/src/stores/user.ts`: 确定的存储 Key (`access_token`, `refresh_token`, `user_info`)。

## 5.3 技术落地计划

### 1. 核心任务定义
- **Store 同步**: 确保 `AuthInterceptor` 使用的存储 Key 与 `useUserStore` 一致。
- **Token 刷新链路**:
  1. `AuthInterceptor.onError` 捕获 401 错误。
  2. 调用 `user.ts` 中的 `refreshToken` API。
  3. 更新本地存储并重试原始请求。
- **路由鉴权配置**: 在 `api-config.ts` 中配置需要 `Authorization` 头部的路径前缀。

### 2. 实现逻辑
1. **拦截器修正**:
   - 将 `AuthInterceptor` 中的 `userToken` 更改为 `access_token`。
   - 将 `userRefToken` 更改为 `refresh_token`。
   - 适配 `refreshToken` 的返回结构。
2. **API 补全**:
   - 在 `services/modules/user.ts` 中添加/更新 `refreshToken` 方法。
3. **配置更新**:
   - 更新 `AUTH_ROUTES` 确保 `/user/`, `/diet-logs/`, `/diet-plans/` 等接口会自动带上 Token。

### 3. 风险点
- **并发刷新**: `AuthInterceptor` 已包含基本的并发刷新队列处理，但需确保其逻辑与 `RequestManager` 的重试机制完全匹配。
- **死循环**: 确保刷新 Token 接口本身不被拦截或在刷新失败时能正确跳转登录页。

## 5.4 验收标准 (T7 预案)
- [ ] 登录后 `access_token` 正确存入 Storage。
- [ ] 调用受保护接口时，Header 包含 `Authorization: Bearer <token>`。
- [ ] 模拟 401 错误时，能够触发自动刷新 Token 逻辑且请求重试成功。
- [ ] Token 刷新失败后，自动跳转至 `/pages/login/index`。