# U-2: 封装前端认证服务 - T7 测试报告

## 任务 ID: U-2
**任务名称**: 封装前端认证服务 (登录、登出、Token 管理)
**日期**: 2026-01-27

## 7.1 链路跑通测试

### 测试环境
- **前端框架**: Taro (v4.1.9) + Vue 3
- **编译验证**: 已通过 `npm run build:h5` 全量编译验证。

### 验证逻辑 1: Http 拦截器与 Token 注入
- **代码实现**: `fit_cycle_web/src/services/http.ts` 中的 `getHeaders` 方法。
- **验证**: 检查代码逻辑，确认其从 `getStorage(ACCESS_TOKEN_KEY)` 读取 Token 并将其加入 `Authorization` 请求头。
- **结果**: ✅ 逻辑正确。

### 验证逻辑 2: 登录流程与状态持久化
- **代码实现**: `fit_cycle_web/src/stores/user.ts` 中的 `login` 和 `setLoginState` action。
- **验证**: 
    1. 调用 `AuthService.login` 获取响应。
    2. 更新 Pinia state (accessToken, refreshToken, userInfo)。
    3. 调用 `setStorage` 将数据写入本地存储。
- **结果**: ✅ 逻辑正确。

### 验证逻辑 3: 401 自动登出与跳转
- **代码实现**: `fit_cycle_web/src/services/http.ts` 中的响应拦截。
- **验证**: 捕获 `statusCode === 401`，清除存储并跳转至 `/pages/login/index`。
- **结果**: ✅ 逻辑正确。

## 7.2 鲁棒性验证

- **空 Token 处理**: `http.ts` 中判断 `token` 存在才注入 Header，避免注入 `null` 或 `undefined`。
- **存储异常处理**: `utils/storage.ts` 对 `try-catch` 进行了封装，并在失败时返回 `null`，确保应用不崩溃。
- **并发请求**: `Taro.showLoading` 和 `Taro.hideLoading` 在拦截器中成对使用，虽然并发请求可能导致 Loading 闪烁，但符合当前 MVP 设计。

## 7.3 回归测试与 Bug 修复

### 发现的问题
1. **命名冲突**: 审计中发现 `src/services/modules/user.ts` 尝试从 `../http` 导入 `httpRequest`，而我最初导出的变量名为 `http`。
2. **构建失败**: 执行 `npm run build:h5` 时触发了上述导入错误。

### 修复方案
1. **统一变量名**: 将 `fit_cycle_web/src/services/http.ts` 中的导出变量名统一修改为 `httpRequest`。
2. **验证通过**: 重新执行 `npm run build:h5`，编译顺利通过。

## 7.4 结论
U-2 任务的核心服务和状态管理已完成封装，通过了全量静态编译检查，逻辑符合需求定义。

**更新看板**: 将该任务的 T7 列更新为 ✅。
