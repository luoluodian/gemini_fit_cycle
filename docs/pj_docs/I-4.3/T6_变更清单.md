# T6 变更清单: I-4.3 历史回溯联调 (History & Preview Backtracking) - V2 闭环版

## 1. Store 层回溯与性能加固 (State Persistence)

### 1.1 内存缓存引擎 (`stores/record.ts`)
- **实现**: 引入 `Map<string, RecordInfoResponse>`。
- **Fetch 重构**: 采用“命中缓存即展示、静默请求后台更”的双态加载模式。
- **自愈同步**: 确保 `addMealLogAction` 和 `removeMealAction` 在成功后自动更新对应日期的 Map 分片。

### 1.2 跨模块缓存失效 (Cache Invalidation)
- **关联注入**: 在 `planStore.ts` 中引入 `recordStore` 实例。
- **触发点**:
    - 在 `resetDraft` 时：强制调用 `recordStore.invalidateAllCache()`。
    - 预留 `onPlanUpdated`：在计划激活/修改成功后执行全量记录缓存清理。
- **目的**: 解决“修改计划后预览目标不即时刷新”的同步难题。

## 2. 逻辑一致性校验点

### 2.1 日期偏移计算
- 确保 `getDateDiff` 保持为私有原子方法，全量支持跨年边界计算。

### 2.2 快照锁定逻辑
- 严格执行：`if (res.record.id) { use_snapshot } else { use_algo }`。

## 3. 验证计划 (Verification)

### 3.1 极速回溯测试
- [ ] 连续滑动日期 10 次，验证是否实现了“无白屏/无骨架屏”的瞬时切换（利用缓存）。

### 3.2 计划变更联动校验 (核心)
- [ ] **Step 1**: 查看明天预览目标 (如 1800)。
- [ ] **Step 2**: 前往计划页修改目标为 2200 并重置/保存。
- [ ] **Step 3**: 返回首页查看明天，验证数值是否**自动更新为 2200** (缓存失效机制生效)。

### 3.3 历史稳定性校验
- [ ] 验证已记录过食物的历史日期，在执行上述计划变更后，目标数值**保持不变** (快照锁定生效)。

## 4. 结论
V2 版 T6 清单确立了 fit_cycle 记录域在“时间轴”上的真理口径。通过建立“计划变更驱动记录缓存失效”的联动机制，我们从工程层面彻底消除了历史快照与未来预览之间的数据冲突风险。