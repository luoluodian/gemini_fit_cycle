# T5 分析文档: I-4.1 打卡保存闭环 (Sync Hook) - V2 增强版

## 1. 任务背景 (Task Background)
任务 **I-4.1** 实现食材选择与入库的真实集成。本版本重点解决了高并发下的重复提交问题，并优化了同步策略，以实现“毫秒级”的视觉反馈。

## 2. 交互逻辑流升级 (Robust Flow)

### 2.1 提交锁与防抖
- **锁定机制**: 在 `handleFoodPicked` 触发时，立即将 `isSubmitting` 设为 true。
- **UI 阻断**: 使用 `Taro.showLoading({ mask: true })` 强制阻断一切背景交互，防止重复点击。

### 2.2 上下文精确绑定
- **餐次锁定**: 明确在打开 `FoodPicker` 之前，首页必须持有稳定的 `currentMealType` 变量。
- **日期溯源**: 打卡日期严格锁定为首页当前展示的 `currentDate` 字符串，不随系统时间偏移。

## 3. 同步策略：局部合并 (Local Merge)
为了提升弱网体验，放弃全量 Fetch：
1.  **POST 调用**: 成功获取后端返回的 `MealLog` 实体。
2.  **Store 合并**:
    - 若 `recordStore.currentRecord` 已存在：直接将新 `MealLog` 追加到 `mealLogs` 数组。
    - 若 `recordStore.currentRecord` 不存在 (今日首次记录)：**必须全量 Fetch** 以获取新生成的 `DailyRecord` 目标快照。

## 4. 技术实现细节 (Implementation)

### 4.1 Store 扩展
- **新增 Action**: `recordStore.addMeal(logData)`。
- **回滚机制**: 若 API 失败，保留当前 UI 状态，提示错误，不清理输入。

### 4.2 弹窗控制
- **逻辑**: 仅在 API 200 成功后执行 `foodPickerVisible.value = false`。

## 5. 潜在风险与对策 (Risks & Mitigations)
- **并发冲突**: 即使前端有锁，后端 R-3 也必须处理 `DuplicateEntry`（已在 R-3 完成）。
- **单位不匹配**: 前端必须显式透传从 `FoodPicker` 选中的 `unit` (克/个/毫升)。

## 6. 结论 (Conclusion)
V2 版 T5 通过“提交锁”和“局部合并”技术，将记录动作的响应体验从“请求-刷新”提升到了“指令-瞬变”的级别，完美诠释了便捷记录的定义。