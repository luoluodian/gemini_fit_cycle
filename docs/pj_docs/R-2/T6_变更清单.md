# T6 变更清单: R-2 每日记录接口 (Record API) - V2 健壮版

## 1. 架构逻辑重构 (Logic Refactoring)
- **非持久化获取**: `GET /records/:date` 改为“纯净读取”模式。若数据库不存在记录，则根据算法**实时计算**目标并返回预览，**不执行数据库插入**。
- **持久化下放**: 真正的 `DailyRecord` 持久化动作将推迟到 R-3（添加第一条餐食记录）时触发。
- **收益**: 彻底杜绝恶意刷 API 导致的僵尸记录膨胀，保持数据库纯净。

## 2. 后端变更清单 (Backend Changes)

### 2.1 模块重命名与注册
- **重命名**: `diet-logs` -> `diet-records`。
- **路由**: `@Controller('records')`。

### 2.2 服务层核心逻辑升级 (`records.service.ts`)
- **实现 `getDailyRecordView(userId, date)`**:
    1. **DB 查询**: `dailyRecordRepo.findOne({ userId, date, relations: ['meals'] })`。
    2. **命中处理**: 若存在，直接返回。
    3. **未命中 (实时计算)**:
        - 调用 `DietPlansService.getActivePlan(userId)`。
        - **边界检查**:
            - 若 `targetDate < plan.startDate` 或 `plan == null`: 走“健康档案兜底”，使用 BMR 计算目标。
            - 正常范围内: 
                - `dayOffset = dayjs(targetDate).diff(plan.startDate, 'day')`。
                - `targetDayNum = (dayOffset % plan.cycleDays) + 1`。
                - 获取对应的 `PlanDay` 目标。
        - **构建虚构对象**: 返回一个未持久化的 `DailyRecord` 对象供前端渲染进度环。

### 2.3 日期处理规范
- **禁止 `Date` 对象**: 全链路使用 `YYYY-MM-DD` 字符串进行比较和存储。
- **时区安全**: 使用 `dayjs().format('YYYY-MM-DD')` 获取服务器当前日期。

## 3. 并发与幂等保障
- **虽然 GET 不落库，但后续 R-3 需实现**:
    - `getOrCreateDailyRecord` 必须包含 `try-catch` 捕获唯一性索引冲突 (`ER_DUP_ENTRY`)。
    - 冲突时二次 `SELECT` 确保业务闭环。

## 4. 验证计划 (Verification)
- **边界测试**:
    - [ ] 访问 `startDate` 之前的日期，验证是否返回 BMR 默认目标。
    - [ ] 访问 `startDate` 之后的日期（跨周期），验证循环计算是否正确。
- **性能测试**: 验证连续调用 `GET` 接口时，数据库 `daily_records` 表的记录数不应增长。
- **关联测试**: 删除计划后，验证历史生成的 `DailyRecord` 是否保持原目标快照（不随计划删除而改变）。

## 5. 依赖
- 依赖 `DietPlansModule` 导出的 `getActivePlan` 方法。
- 依赖 `HealthProfileModule` 导出的 BMR 计算逻辑。