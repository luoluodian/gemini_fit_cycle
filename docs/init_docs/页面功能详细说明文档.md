# 饮食记录小程序 - 页面功能详细说明文档

## 文档说明

本文档以页面为维度，详细说明每个页面中的按钮、组件的功能作用，以及为什么要这样设计和实现。帮助开发团队和产品经理理解每个功能点的业务价值和技术实现。

---

## 登录页面 (/pages/login/index)

### 页面作用

用户进入应用的第一个页面，负责用户身份认证和隐私政策展示。

### 功能组件详解

#### 1. LogoHeader 组件

**作用**: 展示应用品牌标识和名称
**为什么需要**:

- 建立用户对应用的第一印象
- 提升品牌识别度
- 营造专业的应用氛围

#### 2. WelcomeCard 组件

**作用**: 显示欢迎文案和应用价值主张
**为什么需要**:

- 向用户传达应用的核心价值
- 降低用户的心理门槛
- 提升用户继续使用的意愿

#### 3. 微信登录按钮 (LoginButton)

**按钮文案**: "微信一键登录"
**作用**: 触发微信授权登录流程
**实现逻辑**:

```javascript
const handleLogin = async () => {
  // 1. 显示加载状态
  isLoading.value = true;

  // 2. 调用登录服务
  const mockUserInfo = await login({ code: "mock_code" });

  // 3. 存储用户凭证
  setStorage("userToken", `mock_token_${Date.now()}`);
  setStorage("userRefToken", `mock_refresh_${Date.now()}`);
  setStorage("userInfo", mockUserInfo);

  // 4. 跳转到首页
  await navigateTo("/pages/index/index");
};
```

**为什么需要**:

- 微信登录是小程序的标准认证方式
- 提供便捷的用户体验，无需记住额外密码
- 可以获取用户的微信头像和昵称
- 符合微信小程序平台的用户习惯

#### 4. 隐私政策链接

**按钮文案**: "查看隐私政策"
**作用**: 显示隐私政策弹窗
**实现逻辑**:

```javascript
const showPrivacyPolicy = () => {
  privacyModal.value = true; // 显示隐私政策模态框
};
```

**为什么需要**:

- 法律法规要求（《个人信息保护法》）
- 向用户说明数据收集和使用规则
- 建立用户信任
- 避免法律风险

#### 5. 错误提示组件 (ErrorMessage)

**作用**: 显示登录过程中的错误信息
**为什么需要**:

- 提供友好的错误反馈
- 帮助用户理解登录失败原因
- 指导用户进行正确的操作

---

## 首页/记录页面 (/pages/index/index)

### 页面作用

应用的核心页面，展示每日饮食记录、营养目标和计划进度，是用户日常使用的主界面。

### 功能组件详解

#### 1. 日期导航组件 (DateNavigation)

##### 左箭头按钮

**作用**: 切换到前一天
**实现逻辑**:

```javascript
const handlePrevDate = () => {
  const currentDate = new Date(internalDate.value);
  currentDate.setDate(currentDate.getDate() - 1);
  internalDate.value = currentDate.toISOString().split("T")[0];
};
```

**为什么需要**:

- 允许用户查看和编辑历史记录
- 支持用户补录前几天的饮食
- 提供时间维度的导航能力

##### 右箭头按钮

**作用**: 切换到后一天
**实现逻辑**: 同左箭头，方向相反
**为什么需要**:

- 允许用户提前规划未来几天的饮食
- 支持用户查看未来日期的计划安排

##### 日期显示区域

**显示内容**: "今天 · 1 月 8 日" 或 "1 月 8 日"
**作用**: 清晰显示当前选中的日期
**为什么需要**:

- 让用户明确知道正在查看哪一天的记录
- 提供时间上下文，避免用户混淆
- "今天"标识符帮助用户快速识别当前日期

##### 计划信息显示

**显示内容**: "当前计划：6 周减脂计划 (第 7/42 天)"
**作用**: 展示当前激活的计划名称和进度
**为什么需要**:

- 让用户了解当前的计划执行情况
- 提供计划进度的可视化反馈
- 增强用户的参与感和成就感

#### 2. 每日营养目标概览 (DailyGoalsOverview)

**作用**: 以卡片形式展示四大营养素的目标摄入量和当前完成情况
**显示内容**:

- 热量：2800/2800 kcal (100%)
- 蛋白质：85/120g (71%)
- 脂肪：32/50g (64%)
- 碳水化合物：145/180g (81%)

**为什么需要**:

- 提供营养摄入的直观可视化
- 帮助用户了解当前的饮食状况
- 通过进度条激励用户完成每日目标
- 支持用户及时调整饮食计划

#### 3. 餐次记录卡片 (MealCard)

每个餐次卡片包含以下功能：

##### 餐次标题和总热量

**显示内容**: "🌅 早饭 180 kcal"
**作用**: 标识餐次类型和该餐次的总热量摄入
**为什么需要**:

- 让用户快速了解各餐次的营养分布
- 通过表情符号增加视觉识别度
- 提供该餐次的营养汇总信息

##### 食物列表项

**作用**: 展示该餐次中添加的所有食物
**显示内容**: 食物名称、摄入量、热量
**为什么需要**:

- 详细记录用户的饮食内容
- 支持用户查看和编辑具体食物
- 提供准确的营养计算基础

##### "记录本餐"按钮

**按钮文案**: "记录本餐"
**作用**: 按照预设计划自动填充该餐次的食物
**当前状态**: TODO - 未实现
**预期实现逻辑**:

```javascript
const handleAddPlannedMeal = (mealKey: string) => {
  // 1. 获取当前激活的计划
  const activePlan = getActivePlan();

  // 2. 计算当前日期在计划周期中的位置
  const dayInCycle = getCurrentDayInCycle(currentDate.value, activePlan);

  // 3. 获取该日该餐次的预设食物
  const plannedFoods = activePlan.dayTemplates[dayInCycle - 1].meals[mealKey];

  // 4. 自动添加预设食物到当前餐次
  plannedFoods.forEach((food) => {
    addFoodToMeal(mealKey, food);
  });
};
```

**为什么需要**:

- 提高用户记录效率，无需手动添加每个食物
- 确保用户按照计划执行饮食安排
- 减少用户的操作负担，提升使用体验

##### "添加食物"按钮

**按钮文案**: "添加食物"
**作用**: 打开食物选择模态框，手动添加食物
**实现逻辑**:

```javascript
const handleAddFood = (mealKey: string) => {
  currentMealKey.value = mealKey; // 记录当前餐次
  foodModalVisible.value = true; // 显示食物选择模态框
};
```

**为什么需要**:

- 允许用户灵活记录非计划内的食物
- 支持用户自定义每餐的具体内容
- 提供手动记录的备选方案

##### 食物编辑功能

**作用**: 修改已添加食物的数量或删除食物
**当前状态**: TODO - 未完全实现
**为什么需要**:

- 允许用户纠正记录错误
- 支持用户根据实际情况调整食物分量
- 提供完整的食物管理功能

#### 4. 食物选择模态框 (FoodSelectionModal)

**作用**: 提供食物库供用户选择
**包含功能**:

- 食物分类浏览
- 食物搜索功能
- 营养信息展示
- 食物选择确认

**为什么需要**:

- 提供标准化的食物数据库
- 确保营养计算的准确性
- 简化用户的食物录入过程
- 支持用户发现新的食物选择

#### 5. 数量输入模态框 (QuantityInputModal)

**作用**: 让用户输入食物的具体摄入量
**包含功能**:

- 数量输入
- 单位选择
- 营养信息预览
- 确认添加

**为什么需要**:

- 不同摄入量对应不同的营养值
- 需要精确计算实际的营养摄入
- 支持多种计量单位（克、个、毫升等）
- 提供准确的营养分析基础

---

## 计划管理页面 (/pages/plan/index)

### 页面作用

管理用户的饮食计划，包括创建、查看、编辑、分享计划等功能。

### 功能组件详解

#### 1. 计划头部组件 (PlanHeader)

##### "导入计划"按钮

**按钮文案**: "导入计划"
**作用**: 打开计划导入模态框
**实现逻辑**:

```javascript
const showImportPlan = () => {
  showImportPlanModal.value = true;
};
```

**为什么需要**:

- 支持用户通过分享码获取他人分享的计划
- 促进用户间的计划交流和分享
- 提供计划获取的便捷途径

##### "创建计划"按钮

**按钮文案**: "创建计划"
**作用**: 打开创建计划模态框
**实现逻辑**: 同导入计划，打开对应模态框
**为什么需要**:

- 允许用户自定义个性化的饮食计划
- 满足不同用户的特定需求
- 提供灵活的计划创建能力

#### 2. 计划标签页 (PlanTabs)

包含三个标签：进行中、已完成、已归档

**为什么需要**:

- 按状态分类管理计划，提高查找效率
- 让用户清晰了解计划的执行状态
- 支持不同状态计划的批量管理

#### 3. 计划卡片 (PlanCard)

每个计划卡片包含以下信息：

##### 计划基本信息

**显示内容**: 计划名称、类型、进度、剩余天数
**为什么需要**:

- 提供计划的概览信息
- 让用户快速了解计划的关键信息
- 通过进度显示增强用户的成就感

##### 操作按钮组

根据计划状态显示不同的操作按钮：

###### "查看详情"按钮

**作用**: 查看计划的详细信息
**为什么需要**:

- 提供计划的完整信息查看
- 支持用户深入了解计划内容
- 为后续的计划管理提供基础

###### "激活"按钮（暂停状态）

**作用**: 将暂停的计划重新激活
**实现逻辑**:

```javascript
const activatePlan = (planId: string) => {
  // 取消当前激活的计划
  allPlans.value.forEach((p) => {
    if (p.status === "active" && p.id !== planId) {
      p.status = "paused";
    }
  });

  // 激活选中的计划
  const plan = allPlans.value.find((p) => p.id === planId);
  if (plan) {
    plan.status = "active";
    setStorage(ACTIVE_PLAN_KEY, planId);
    savePlans();
  }
};
```

**为什么需要**:

- 允许用户切换当前执行的计划
- 确保同时只有一个激活的计划
- 支持用户灵活管理多个计划

###### "编辑"按钮（进行状态）

**作用**: 修改计划的基本信息
**为什么需要**:

- 允许用户调整计划参数
- 支持计划的动态调整
- 满足用户的个性化需求

###### "再次使用"按钮（已完成状态）

**作用**: 基于已完成计划创建新计划
**为什么需要**:

- 复用成功的计划模板
- 减少用户重新创建的工作量
- 延续有效的饮食方案

###### "恢复"按钮（已归档状态）

**作用**: 将归档的计划恢复到暂停状态
**为什么需要**:

- 允许用户重新使用历史计划
- 提供计划的生命周期管理
- 避免用户重复创建相似计划

##### 更多操作菜单（⋮ 按钮）

**包含功能**: 编辑计划、分享计划、复制计划、归档计划、删除计划

**为什么需要**:

- 提供完整的计划管理功能
- 将次要操作收纳到菜单中，保持界面简洁
- 支持高级用户进行深度计划管理

#### 4. 计划统计组件 (PlanStats)

**显示内容**: 激活计划数量、已完成计划数量
**为什么需要**:

- 提供用户计划执行的总体情况
- 通过数据激励用户持续使用
- 帮助用户了解自己的计划管理情况

#### 5. 推荐计划组件 (RecommendedPlans)

**包含内容**: 减脂挑战、增肌训练、均衡营养三个预设模板
**为什么需要**:

- 为新用户提供快速入门的方案
- 基于专业营养知识提供科学的计划模板
- 降低用户创建计划的门槛

#### 6. 悬浮创建按钮 (Floating Action Button)

**按钮样式**: 圆形的"+"号按钮
**作用**: 快速打开创建计划模态框
**为什么需要**:

- 提供醒目的计划创建入口
- 符合移动端的设计习惯
- 支持用户随时创建新计划

---

## 通用功能说明

### 1. 模态框设计模式

应用中的模态框（Modal）采用统一的设计模式：

**为什么采用模态框**:

- 保持当前页面上下文，不丢失用户位置
- 提供专注的操作环境
- 支持复杂的表单和数据展示
- 用户可以随时取消操作

### 2. 数据验证机制

所有表单输入都包含数据验证：

**验证内容**:

- 必填字段检查
- 数值范围验证（如热量 800-4000kcal）
- 数据格式验证
- 业务逻辑验证

**为什么需要**:

- 保证数据的完整性和准确性
- 防止用户输入不合理的数据
- 提供友好的错误提示
- 减少后端处理错误

### 3. 本地存储策略

应用使用本地存储保存关键数据：

**存储内容**:

- 用户登录信息和 token
- 饮食计划和记录数据
- 用户偏好设置
- 应用状态信息

**为什么使用本地存储**:

- 提供离线使用能力
- 减少服务器请求，提升性能
- 支持数据的持久化保存
- 实现快速的数据访问

### 4. 错误处理机制

应用采用统一的错误处理策略：

**错误类型**:

- 网络请求错误
- 数据验证错误
- 业务逻辑错误
- 用户操作错误

**处理方式**:

- 友好的错误提示（Toast）
- 详细的错误日志
- 自动的错误恢复
- 用户指导建议

**为什么需要**:

- 提升用户体验，避免应用崩溃
- 帮助用户理解和解决问题
- 便于开发团队定位和修复问题
- 保证应用的稳定运行

---

## 总结

本业务逻辑文档详细说明了每个页面中各个功能组件的作用和实现逻辑。设计这些功能的核心理念是：

### 1. 用户体验优先

- 简化操作流程，减少用户思考
- 提供直观的视觉反馈
- 支持灵活的操作方式

### 2. 数据准确性

- 确保营养计算的精确性
- 提供完整的数据记录
- 支持数据的灵活编辑

### 3. 功能完整性

- 覆盖饮食记录的全流程
- 提供计划管理的完整生命周期
- 支持用户个性化的需求

### 4. 技术可靠性

- 采用成熟的技术方案
- 实现完善的错误处理
- 保证应用的稳定运行

通过这些详细的功能设计，应用能够为用户提供专业、便捷、可靠的饮食记录和营养管理服务。
